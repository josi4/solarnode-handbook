{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SolarNode Handbook","text":"<p>This handbook provides guides and reference documentation about SolarNode, the distributed computing part of SolarNetwork.</p> <p> SolarNode is the swiss army knife for IoT monitoring and control. It is deployed on inexpensive computers in homes, buildings, vehicles, and even EV chargers, connected to any number of sensors, meters, building automation systems, and more. There are several SolarNode icons in the image below. Can you spot them all?</p> <p></p>"},{"location":"#user-guide","title":"User Guide","text":"<p>For information on getting and using SolarNode, see the User Guide.</p>"},{"location":"#developer-guide","title":"Developer Guide","text":"<p>For information on working on the SolarNode codebase, such as writing a plugin, see the Developer Guide.</p>"},{"location":"developers/","title":"Developer Guide","text":"<p>This section of the handbook is geared towards developers working with the SolarNode codebase to develop a plugin.</p>"},{"location":"developers/#solarnode-source","title":"SolarNode source","text":"<p>The core SolarNode platform code is available on GitHub.</p>"},{"location":"developers/#getting-started","title":"Getting started","text":"<p>See the SolarNode Development Guide to set up your own development environment for writing SolarNode plugins.</p>"},{"location":"developers/#solarnode-debugging","title":"SolarNode debugging","text":"<p>You can enable Java remote debugging for SolarNode on a node device for SolarNode plugin development or troubleshooting by modifying the SolarNode service environment. Once enabled, you can use SSH port forwarding to enable Java remote debugging in your Java IDE of choice.</p> <p>To enable Java remote debugging, copy the <code>/etc/solarnode/env.conf.example</code> file to <code>/etc/solarnode/env.conf</code>. The example already includes this support, using port <code>9142</code> for the debugging port. Then restart the <code>solarnode</code> service:</p> Creating a custom SolarNode environment with debugging support<pre><code>$ cp /etc/solarnode/env.conf.example /etc/solarnode/env.conf\n$ sn-restart\n</code></pre> <p>Then you can use <code>ssh</code> from your development machine to forward a local port to the node's <code>9142</code> port, and then have your favorite IDE establish a remote debugging connection on your local port.</p> <p>For example, on a Linux or macOS machine you could forward port <code>8000</code> to a node's port <code>9142</code> like this:</p> Creating a port-forwarding SSH connection from a development machine to SolarNode<pre><code>$ ssh -L8000:localhost:9142 solar@solarnode\n</code></pre> <p>Once that <code>ssh</code> connection is established, your IDE can be used to connect to <code>localhost:8000</code> for a remote Java debugging session.</p>"},{"location":"developers/osgi/","title":"Plugins","text":"<p>The SolarNode platform has been designed to be highly modular and dynamic, by using a plugin-based architecture. The plugin system SolarNode uses is based on the OSGi specification, where plugins are implemented as OSGi bundles. SolarNode can be thought of as a collection of OSGi bundles that, when combined and deployed together in an OSGi framework like Eclipse Equinox, form the complete SolarNode platform.</p> <p>To summarize: everything in SolarNode is a plugin!</p> <p>OSGi bundles and Eclipse plug-ins</p> <p>Each OSGi bundle in SolarNode comes configured as an Eclipse IDE (or simply Eclipse) plug-in project. Eclipse refers to OSGi bundles as \"plug-ins\" and its OSGi development tools are collectively known as the Plug-in Development Environment, or PDE for short. We use the terms bundle and plug-in and plugin somewhat interchangably in the SolarNode project. Although Eclipse is not actually required for SolarNode development, it is very convenient.</p> <p>Practically speaking a plugin, which is an OSGi bundle, is simply a Java JAR file that includes the Java code implementing your plugin and some OSGi metadata in its Manifest. For example, here is the contents of the <code>net.solarnetwork.common.jdt</code> plugin JAR:</p> <pre><code>META-INF/MANIFEST.MF\nnet/solarnetwork/common/jdt/Activator.class\nnet/solarnetwork/common/jdt/ClassLoaderNameEnvironment.class\nnet/solarnetwork/common/jdt/CollectingCompilerRequestor.class\nnet/solarnetwork/common/jdt/CompilerUtils.class\nnet/solarnetwork/common/jdt/JdtJavaCompiler.class\nnet/solarnetwork/common/jdt/MapClassLoader.class\nnet/solarnetwork/common/jdt/ResourceCompilationUnit.class\n</code></pre>"},{"location":"developers/osgi/#services","title":"Services","text":"<p>Central to the plugin architecture SolarNode uses is the concept of a service. In SolarNode a service is defined by a Java interface. A plugin can advertise a service to the SolarNode runtime. Plugins can lookup a service in the SolarNode runtime and then invoke the methods defined on it.</p> <p>The advertising/lookup framework SolarNode uses is provided by OSGi. OSGi provides several ways to manage services. In SolarNode the most common is to use Blueprint XML documents to both publish services (advertise) and acquire references to services (lookup).</p>"},{"location":"developers/osgi/blueprint-compendium/","title":"Gemini Blueprint Compendium","text":"<p>The Gemini Blueprint implementation provides some useful extensions that SolarNode makes frequent use of.  To use the extensions you need to declare the Gemini Blueprint Compendium namespace in your Blueprint  XML file, like this:</p> Gemini Blueprint Compendium XML declaration<pre><code>&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:osgix=\"http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\"\nxmlns:beans=\"http://www.springframework.org/schema/beans\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium/gemini-blueprint-compendium.xsd\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n</code></pre> <p>This example declares the Gemini Blueprint Compendium XML namespace prefix <code>osgix</code> and a related Spring Beans namespace prefix <code>beans</code>. You will see those used throughout SolarNode.</p>"},{"location":"developers/osgi/blueprint-compendium/#managed-properties","title":"Managed Properties","text":"<p>Managed Properties provide a way to use the Configuration Admin service to manage user-configurable service properties. Conceptually it is like linking a class to a set of dynamic runtime Settings: Configuration Admin provides change event and persistence APIs for the settings, and the Managed Properties applies those settings to the linked service.</p> <p>Imagine you have a service class <code>MyService</code> with a configurable property <code>level</code>. We can make that property a managed, persistable setting by adding a <code>&lt;osgix:managed-properties&gt;</code> element to our Blueprint XML, like this:</p> MyService classMyService localizationBlueprint XML <pre><code>package com.example;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport net.solarnetwork.node.service.support.BaseIdentifiable;\nimport net.solarnetwork.settings.SettingSpecifier;\nimport net.solarnetwork.settings.SettingSpecifierProvider;\nimport net.solarnetwork.settings.SettingsChangeObserver;\nimport net.solarnetwork.settings.support.BasicTextFieldSettingSpecifier;\n\n/**\n * My super-duper service.\n *\n * @author matt\n * @version 1.0\n */\npublic class MyService extends BaseIdentifiable\nimplements SettingsChangeObserver, SettingSpecifierProvider {\n\nprivate int level;\n\n@Override\npublic String getSettingUid() {\nreturn \"com.example.MyService\"; // (1)!\n}\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nreturn Collections.singletonList(\nnew BasicTextFieldSettingSpecifier(\"level\", String.valueOf(0)));\n}\n\n@Override\npublic void configurationChanged(Map&lt;String, Object&gt; properties) {\n// the settings have changed; do something\n}\n\npublic int getLevel() {\nreturn level;\n}\n\npublic void setLevel(int level) {\nthis.level = level;\n}\n\n}\n</code></pre> <ol> <li>The setting UID will be the Configuration Admin PID</li> </ol> <pre><code>title = Super-duper Service\ndesc = This service does it all.\n\nlevel.key = Level\nlevel.desc = This one goes to 11.\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:osgix=\"http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\"\nxmlns:beans=\"http://www.springframework.org/schema/beans\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium/gemini-blueprint-compendium.xsd\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n&lt;service&gt;\n&lt;interfaces&gt;\n&lt;value&gt;net.solarnetwork.settings.SettingSpecifierProvider&lt;/value&gt;\n&lt;/interfaces&gt;\n&lt;bean class=\"com.example.MyService\"&gt;&lt;!-- (1)! --&gt;\n&lt;osgix:managed-properties\npersistent-id=\"com.example.MyService\"\nautowire-on-update=\"true\"\nupdate-method=\"configurationChanged\"/&gt;\n&lt;property name=\"messageSource\"&gt;\n&lt;bean class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt;\n&lt;property name=\"basenames\" value=\"com.example.MyService\"/&gt;\n&lt;/bean&gt;\n&lt;/property&gt;\n&lt;/bean&gt;\n&lt;/service&gt;\n\n&lt;/blueprint&gt;\n</code></pre> <ol> <li>You nest the <code>&lt;osgi:managed-properties&gt;</code> element within the actual service <code>&lt;bean&gt;</code> element    you want to apply the managed settings on.<ul> <li>note how the <code>persistent-id</code> attribute value matches the <code>getSettingsUid()</code> value in   <code>MyService.java</code></li> <li>the <code>autowire-on-update</code> method toggles having the Managed Properties automatically applied by   Gemini Blueprint; you can set to <code>false</code> and provide an <code>update-method</code> if you want to handle   changes yourself</li> <li>the <code>update-method</code> attribute is optional; it provides a way for the service to be notified   after the Configuration Admin settings have been applied.</li> </ul> </li> </ol> <p>When this plugin is deployed in SolarNode, the component will appear on the main Settings page and offer a configurable Level setting, like this:</p> <p></p>"},{"location":"developers/osgi/blueprint-compendium/#managed-service-factory","title":"Managed Service Factory","text":"<p>The Managed Service Factory service provide a way to use the Configuration Admin service to manage multiple copies of a user-configurable service's properties. Conceptually it is like linking a class to a set of dynamic runtime Settings, but you can create as many independent copies as you like. Configuration Admin provides change event and persistence APIs for the settings, and the Managed Service Factory applies those settings to each linked service instance.</p> <p>Imagine you have a service class <code>ManagedService</code> with a configurable property <code>level</code>. We can make that property a factory of managed, persistable settings by adding a <code>&lt;osgix:managed-service-factory&gt;</code> element to our Blueprint XML, like this:</p> MyService classMyService localizationBlueprint XML <pre><code>package com.example;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport net.solarnetwork.node.service.support.BaseIdentifiable;\nimport net.solarnetwork.settings.SettingSpecifier;\nimport net.solarnetwork.settings.SettingSpecifierProvider;\nimport net.solarnetwork.settings.SettingsChangeObserver;\nimport net.solarnetwork.settings.support.BasicTextFieldSettingSpecifier;\n\n/**\n * My super-duper managed service.\n *\n * @author matt\n * @version 1.0\n */\npublic class ManagedService extends BaseIdentifiable\nimplements SettingsChangeObserver, SettingSpecifierProvider {\n\nprivate int level;\n\n@Override\npublic String getSettingUid() {\nreturn \"com.example.ManagedService\"; // (1)!\n}\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nreturn Collections.singletonList(\nnew BasicTextFieldSettingSpecifier(\"level\", String.valueOf(0)));\n}\n\n@Override\npublic void configurationChanged(Map&lt;String, Object&gt; properties) {\n// the settings have changed; do something\n}\n\npublic int getLevel() {\nreturn level;\n}\n\npublic void setLevel(int level) {\nthis.level = level;\n}\n\n}\n</code></pre> <ol> <li>The setting UID will be the Configuration Admin factory PID</li> </ol> <pre><code>title = Super-duper Managed Service\ndesc = This managed service does it all.\n\nlevel.key = Level\nlevel.desc = This one goes to 11.\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:osgix=\"http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\"\nxmlns:beans=\"http://www.springframework.org/schema/beans\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium/gemini-blueprint-compendium.xsd\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt;\n&lt;property name=\"basenames\" value=\"com.example.ManagedService\"/&gt;\n&lt;/bean&gt;\n\n&lt;service interface=\"net.solarnetwork.settings.SettingSpecifierProviderFactory\"&gt;&lt;!-- (1)! --&gt;\n&lt;bean class=\"net.solarnetwork.settings.support.BasicSettingSpecifierProviderFactory\"&gt;\n&lt;property name=\"displayName\" value=\"Super-duper Managed Service\"/&gt;\n&lt;property name=\"factoryUid\" value=\"com.example.ManagedService\"/&gt;&lt;!-- (2)! --&gt;\n&lt;property name=\"messageSource\" ref=\"messageSource\"/&gt;\n&lt;/bean&gt;\n&lt;/service&gt;\n\n&lt;osgix:managed-service-factory\nfactory-pid=\"com.example.ManagedService\"\nautowire-on-update=\"true\"\nupdate-method=\"configurationChanged\"&gt;&lt;!-- (3)! --&gt;\n&lt;osgix:interfaces&gt;\n&lt;beans:value&gt;net.solarnetwork.settings.SettingSpecifierProvider&lt;/beans:value&gt;\n&lt;/osgix:interfaces&gt;\n&lt;osgix:service-properties&gt;\n&lt;beans:entry key=\"settingPid\" value=\"com.example.ManagedService\"/&gt;\n&lt;/osgix:service-properties&gt;\n&lt;bean class=\"com.example.ManagedService\"&gt;\n&lt;property name=\"messageSource\" ref=\"messageSource\"/&gt;\n&lt;/bean&gt;\n&lt;/osgix:managed-service-factory&gt;\n\n&lt;/blueprint&gt;\n</code></pre> <ol> <li>The <code>SettingSpecifierProviderFactory</code> service is what makes the managed service factory    appear as a component in the SolarNode Settings UI.</li> <li>The <code>factoryUid</code> defines the Configuration Admin factory PID and the Settings UID.</li> <li>You add a <code>&lt;osgix:managed-service-factory&gt;</code> element in your Blueprint XML, with a nested    <code>&lt;bean&gt;</code> \"template\" within it. The template bean will be instantiated for each service    instance instantiated by the Managed Service Factory.<ul> <li>note how the <code>factory-pid</code> attribute value matches the <code>getSettingsUid()</code> value in   <code>ManagedService.java</code> and the <code>factoryUid</code> declared in #2.</li> <li>the <code>autowire-on-update</code> method toggles having the Managed Properties automatically applied by   Gemini Blueprint; you can set to <code>false</code> and provide an <code>update-method</code> if you want to handle   changes yourself</li> <li>the <code>update-method</code> attribute is optional; it provides a way for the service to be notified   after the Configuration Admin settings have been applied.</li> </ul> </li> </ol> <p>When this plugin is deployed in SolarNode, the managed component will appear on the main Settings page like this:</p> <p></p> <p>After clicking on the Manage button next to this component, the Settings UI allows you to create any number of instances of the component, each with their own setting values. Here is a screen shot showing two instances having been created:</p> <p></p>"},{"location":"developers/osgi/blueprint/","title":"Blueprint","text":"<p>SolarNode supports the OSGi Blueprint Container Specification so plugins can declare their service dependencies and register their services by way of an XML file deployed with the plugin. If you are familiar with the Spring Framework's XML configuration, you will find Blueprint very similar. SolarNode uses the Eclipse Gemini implementation of the Blueprint specification, which is directly derived from Spring Framework.</p> <p>Note</p> <p>This guide will not document the full Blueprint XML syntax. Rather, it will attempt to showcase the most common parts used in SolarNode. Refer to the Blueprint Container Specification for full details of the specification.</p>"},{"location":"developers/osgi/blueprint/#example","title":"Example","text":"<p>Imagine you are working on a plugin and have a <code>com.example.Greeter</code> interface you would like to register as a service for other plugins to use, and an implementation of that service in  <code>com.example.HelloGreeter</code> that relies on the Placeholder  Service provided by SolarNode:</p> Greeter serviceHelloGreeter implementation <pre><code>package com.example;\npublic interface Greeter {\n\n/**\n     * Greet something with a given name.\n     * @param name the name to greet\n     * @return the greeting\n     */\nString greet(String name);\n\n}\n</code></pre> <pre><code>package com.example;\nimport net.solarnetwork.node.service.PlaceholderService;\npublic class HelloGreeter implements Greeter {\n\nprivate final PlaceholderService placeholderService;\n\npublic HelloGreeter(PlaceholderService placeholderService) {\nsuper();\nthis.placeholderService = placeholderService;\n}\n\n@Override\npublic String greet(String name) {\nreturn placeholderService.resolvePlaceholders(\nString.format(\"Hello %s, from {myName}.\", name),\nnull);\n}\n}\n</code></pre> <p>Assuming the <code>PlaceholderService</code> will resolve <code>{name}</code> to <code>Office Node</code>, we would expect the <code>greet()</code> method to run like this:</p> <pre><code>Greeter greeter = resolveGreeterService();\nString result = greeter.greet(\"Joe\");\n// result is \"Hello Joe, from Office Node.\"\n</code></pre> <p>In the plugin we then need to:</p> <ol> <li>Obtain a <code>net.solarnetwork.node.service.PlaceholderService</code> to pass to the     <code>HelloGreeter(PlaceholderService)</code> constructor</li> <li>Register  the <code>HelloGreeter</code> comopnent as a <code>com.example.Greeter</code> service in the SolarNode     platform</li> </ol> <p>Here is an example Blueprint XML document that does both:</p> Blueprint XML example<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\"&gt;\n\n&lt;!-- Declare a reference (lookup) to the PlaceholderService --&gt;\n&lt;reference id=\"placeholderService\"\ninterface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n\n&lt;service interface=\"com.example.Greeter\"&gt;\n&lt;bean class=\"com.example.HelloGreeter\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;/bean&gt;\n&lt;/service&gt;\n\n&lt;/blueprint&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#blueprint-xml-resources","title":"Blueprint XML Resources","text":"<p>Blueprint XML documents are added to a plugin's <code>OSGI-INF/blueprint</code> classpath location. A plugin can provide any number of Blueprint XML documents there, but often a single file is sufficient and a common convention in SolarNode is to name it <code>module.xml</code>.</p>"},{"location":"developers/osgi/blueprint/#xml-syntax","title":"XML Syntax","text":"<p>A minimal Blueprint XML file is structured like this:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\"&gt;\n\n&lt;!-- Plugin components configured here --&gt;\n\n&lt;/blueprint&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#service-references","title":"Service References","text":"<p>To make use of services registered by SolarNode plugins, you declare a reference to that service so you may refer to it elsewhere within the Blueprint XML. For example, imagine you wanted to use the Placeholder Service in your component. You would obtain a reference to that like this:</p> <pre><code>&lt;reference id=\"placeholderService\"\ninterface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n</code></pre> <p>The <code>id</code> attribute allows you to refer to this service elsewhere in your Blueprint XML, while <code>interface</code> declares the fully-qualified Java interface of the service you want to use.</p>"},{"location":"developers/osgi/blueprint/#components","title":"Components","text":"<p>Components in Blueprint are Java classes you would like instantiated when your plugin starts. They are declared using a <code>&lt;bean&gt;</code> element in Blueprint XML. You can assign each component a unique identifier using an <code>id</code> attribute, and then you can refer to that component in other components.</p> <p>Imagine an example component class <code>com.example.MyComponent</code>:</p> <pre><code>package com.example;\n\nimport net.solarnetwork.node.service.PlaceholderService;\n\npublic class MyComponent {\n\nprivate final PlaceholderService placeholderService;\nprivate int minimum;\n\npublic MyComponent(PlaceholderService placeholderService) {\nsuper();\nthis.placeholderService = placeholderService;\n}\n\npublic String go() {\nreturn PlaceholderService.resolvePlaceholders(placeholderService,\n\"{building}/temp\", null);\n}\n\npublic int getMinimum() {\nreturn minimum;\n}\n\npublic void setMinimum(int minimum) {\nthis.minimum = minimum;\n}\n}\n</code></pre> <p>Here is how that component could be declared in Blueprint:</p> <pre><code>&lt;reference id=\"placeholderService\"\ninterface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n\n&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;property name=\"minimum\" value=\"10\"/&gt;\n&lt;/bean&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#constructor-arguments","title":"Constructor Arguments","text":"<p>If your component requires any constructor arguments, they can be specified with nested <code>&lt;argument&gt;</code> elements in Blueprint. The <code>&lt;argument&gt;</code> value can be specified as a reference to another component using a <code>ref</code> attribute whose value is the <code>id</code> of that component, or as a literal value using a <code>value</code> attribute.</p> <p>For example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;argument value=\"10\"&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#property-accessors","title":"Property Accessors","text":"<p>You can configure mutable class properties on a component with nested <code>&lt;property name=\"\"&gt;</code> elements in Blueprint. A mutable property is a Java setter method. For example an <code>int</code> property <code>minimum</code> would be associated with a Java setter method <code>public void setMinimum(int value)</code>.</p> <p>The <code>&lt;property&gt;</code> value can be specified as a reference to another component using a <code>ref</code> attribute whose value is the <code>id</code> of that component, or as a literal value using a <code>value</code> attribute.</p> <p>For example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;property name=\"placeholderService\" ref=\"placeholderService\"&gt;\n&lt;argument name=\"minimum\" value=\"10\"&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#startstop-hooks","title":"Start/Stop Hooks","text":"<p>Blueprint can invoke a method on your component when it has finished instantiating and configuring the object (when the plugin starts), and another when it destroys the instance (when the plugin is stopped). You simply provide the name of the method you would like Blueprint to call in the <code>init-method</code> and <code>destroy-method</code> attributes of the <code>&lt;bean&gt;</code> element. For example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"\ninit-method=\"startup\"\ndestroy-method=\"shutdown\"&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#service-registration","title":"Service Registration","text":"<p>You can make any component available to other plugins by registering the component with a <code>&lt;service&gt;</code> element that declares what interface(s) your component provides. Once registered, other plugins can make use of your component, for example by declaring a <code>&lt;referenece&gt;</code> to your component class in their Blueprint XML.</p> <p>Note</p> <p>You can only register Java interfaces as services, not classes.</p> <p>For example, imagine a <code>com.example.Startable</code> interface like this:</p> <pre><code>package com.example;\npublic interface Startable {\n/**\n     * Start!\n     * @return the result\n     */\nString go();\n}\n</code></pre> <p>We could implement that interface in the <code>MyComponent</code> class, like this:</p> <pre><code>package com.example;\n\npublic class MyComponent implements Startable {\n\n@Override\npublic String go() {\nreturn \"Gone!\";\n}\n}\n</code></pre> <p>We can register <code>MyComponent</code> as a <code>Startable</code> service using a <code>&lt;service&gt;</code> element like this in Blueprint:</p> Direct service componentIndirect service component <pre><code>&lt;service interface=\"com.example.Startable\"&gt;\n&lt;!-- The service implementation is nested directly within --&gt;\n&lt;bean class=\"com.example.MyComponent\"/&gt;\n&lt;/service&gt;\n</code></pre> <pre><code>&lt;!-- The service implementation is referenced indirectly... --&gt;\n&lt;service ref=\"myComponent\" interface=\"com.example.Startable\"/&gt;\n\n&lt;!-- ... to a bean with a matching id attribute --&gt;\n&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"/&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#multiple-service-interfaces","title":"Multiple Service Interfaces","text":"<p>You can advertise any number of service interfaces that your component supports, by nesting an <code>&lt;interfaces&gt;</code> element within the <code>&lt;service&gt;</code> element, in place of the <code>interface</code> attribute. For example:</p> <pre><code>&lt;service ref=\"myComponent\"&gt;\n&lt;interfaces&gt;\n&lt;value&gt;com.example.Startable&lt;/value&gt;\n&lt;value&gt;com.example.Stopable&lt;/value&gt;\n&lt;/interfaces&gt;\n&lt;/service&gt;\n</code></pre>"},{"location":"developers/osgi/blueprint/#export-service-packages","title":"Export service packages","text":"<p>For a registered service to be of any use to another plugin, the package the service is defined in must be exported by the plugin hosting that package. That is because the plugin wishing to add a reference to the service will need to import the package in order to use it.</p> <p>For example, the plugin that hosts the <code>com.example.service.MyService</code> service would need a manifest file that includes an <code>Export-Package</code> attribute similar to:</p> <pre><code>Export-Package: com.example.service;version=\"1.0.0\"\n</code></pre>"},{"location":"developers/osgi/configuration-admin/","title":"Configuration Admin","text":"<p>TODO</p>"},{"location":"developers/osgi/life-cycle/","title":"Life cycle","text":"<p>Plugins in SolarNode can be added to and removed from the platform at any time without restarting the SolarNode process, because of the Life Cycle process OSGi manages. The life cycle of a plugin consists of a set of states and OSGi will transition a plugin's state over the course of the plugin's life.</p> <p>The available plugin states are:</p> State Description <code>INSTALLED</code> The plugin has been successfully added to the OSGi framework. <code>RESOLVED</code> All package dependencies that the bundle needs are available. This state indicates that the plugin is either ready to be started or has stopped. <code>STARTING</code> The plugin is being started by the OSGi framework, but it has not finished starting yet. <code>ACTIVE</code> The plugin has been successfully started and is running. <code>STOPPING</code> The plugin is being stopped by the OSGi framework, but it has not finished stopping yet. <code>UNINSTALLED</code> The plugin has been removed by the OSGi framework. It cannot change to another state. <p>The possible changes in state can be visualized in the following state-change diagram:</p> <p> </p> <p>Faisal.akeel, Public domain, via Wikimedia Common</p>"},{"location":"developers/osgi/life-cycle/#activator","title":"Activator","text":"<p>A plugin can opt in to receiving callbacks for the start/stop state transitions by providing an <code>org.osgi.framework.BundleActivator</code> implementation and declaring that class in the <code>Bundle-Activator</code> manifest attribute. This can be useful when a plugin needs to initialize some resources when the plugin is started, and then release those resources when the plugin is stopped.</p> BundleActivator APIBundleActivator implementation exampleManifest declaration example <pre><code>public interface BundleActivator {\n/**\n     * Called when this bundle is started so the Framework can perform the\n     * bundle-specific activities necessary to start this bundle.\n     *\n     * @param context The execution context of the bundle being started.\n     */\npublic void start(BundleContext context) throws Exception;\n\n/**\n     * Called when this bundle is stopped so the Framework can perform the\n     * bundle-specific activities necessary to stop the bundle.\n     *\n     * @param context The execution context of the bundle being stopped.\n     */\npublic void stop(BundleContext context) throws Exception;\n}\n</code></pre> <pre><code>package com.example.activator;\nimport org.osgi.framework.BundleActivator;\nimport org.osgi.framework.BundleContext;\npublic class Activator implements BundleActivator {\n\n@Override\npublic void start(BundleContext bundleContext) throws Exception {\n// initialize resources here\n}\n\n@Override\npublic void stop(BundleContext bundleContext) throws Exception {\n// clean up resources here\n}\n}\n</code></pre> <pre><code>Manifest-Version: 1.0\nBundle-ManifestVersion: 2\nBundle-Name: Example Activator\nBundle-SymbolicName: com.example.activator\nBundle-Version: 1.0.0\nBundle-Activator: com.example.activator.Activator\nImport-Package: org.osgi.framework;version=\"[1.3,2.0)\"\n</code></pre> <p>Tip</p> <p>Often making use of the component life cycle hooks available in Blueprint are sufficient and no <code>BundleActivator</code> is necessary.</p>"},{"location":"developers/osgi/manifest/","title":"Manifest","text":"<p>As SolarNode plugins are OSGi bundles, which are Java JAR files, every plugin automatically includes a <code>META-INF/MANIFEST.MF</code> file as defined in the Java JAR File Specification. The <code>MANIFEST.MF</code> file is where OSGi metadata is included, turning the JAR into an OSGi bundle (plugin).</p>"},{"location":"developers/osgi/manifest/#example","title":"Example","text":"<p>Here is an example snippet from the SolarNode net.solarnetwork.common.jdt plugin:</p> Example plugin MANIFEST.MF<pre><code>Manifest-Version: 1.0\nBundle-ManifestVersion: 2\nBundle-Name: Java Compiler Service (JDT)\nBundle-SymbolicName: net.solarnetwork.common.jdt\nBundle-Description: Java complier using Eclipse JDT.\nBundle-Version: 3.0.0\nBundle-Vendor: SolarNetwork\nBundle-RequiredExecutionEnvironment: JavaSE-1.8\nBundle-Activator: net.solarnetwork.common.jdt.Activator\nExport-Package:\nnet.solarnetwork.common.jdt;version=\"2.0.0\"\nImport-Package:\nnet.solarnetwork.service;version=\"[1.0,2.0)\",\norg.eclipse.jdt.core.compiler,\norg.eclipse.jdt.internal.compiler,\norg.osgi.framework;version=\"[1.5,2.0)\",\norg.slf4j;version=\"[1.7,2.0)\",\norg.springframework.context;version=\"[5.3,6.0)\",\norg.springframework.core.io;version=\"[5.3,6.0)\",\norg.springframework.util;version=\"[5.3,6.0)\"\n</code></pre> <p>The rest of this document will describe this structure in more detail.</p>"},{"location":"developers/osgi/manifest/#versioning","title":"Versioning","text":"<p>In OSGi plugins are always versioned and and Java packages may be versioned. Versions follow Semantic Versioning rules, generally using this syntax:</p> <pre><code>major.minor.patch\n</code></pre> <p>In the manifest example you can see the plugin version <code>3.0.0</code> declared in the <code>Bundle-Version</code> attribute:</p> <pre><code>Bundle-Version: 3.0.0\n</code></pre> <p>The example also declares (exports) a <code>net.solarnetwork.common.jdt</code> package for other plugins to import (use) as version <code>2.0.0</code>, in the <code>Export-Package</code> attribute:</p> <pre><code>Export-Package:\nnet.solarnetwork.common.jdt;version=\"2.0.0\"\n</code></pre> <p>The example also uses (imports) a versioned package <code>net.solarnetwork.service</code> using a version range greater than or equal to <code>1.0</code> and less than <code>2.0</code> and an unversioned package <code>org.eclipse.jdt.core.compiler</code>, in the <code>Import-Package</code> attribute:</p> <pre><code>Import-Package:\nnet.solarnetwork.service;version=\"[1.0,2.0)\",\norg.eclipse.jdt.core.compiler,\n</code></pre> <p>Tip</p> <p>Some plugins, and core Java system packages, do not declare package versions. You should declare package versions in your own plugins.</p>"},{"location":"developers/osgi/manifest/#version-ranges","title":"Version ranges","text":"<p>Some OSGi version attributes allow version ranges to be declared, such as the <code>Import-Package</code> attribute. A version range is a comma-delimited <code>lower,upper</code> specifier. Square brackets are used to represent inclusive  values and round brackets represent exclusive values. A value can be omitted to reprsent an unbounded value. Here are some examples:</p> Range Logic Description <code>[1.0,2.0)</code> 1.0.0 \u2264 x &lt; 2.0.0 Greater than or equal to <code>1.0.0</code> and less than <code>2.0.0</code> <code>(1,3)</code> 1.0.0 &lt; x &lt; 3.0.0 Greater than <code>1.0.0</code> and less than <code>3.0.0</code> <code>[1.3.2,)</code> 1.3.2 \u2264 x Greater than or eequal to <code>1.3.2</code> <code>1.3.2</code> 1.3.2 \u2264 x Greater than or eequal to <code>1.3.2</code> (shorthand notation) <p>Implied unbounded range</p> <p>An inclusive lower, unbounded upper range can be specifeid using a shorthand notation of just the lower bound, like <code>1.3.2</code>.</p>"},{"location":"developers/osgi/manifest/#required-attributes","title":"Required attributes","text":"<p>Each plugin must provide the following attributes:</p> Attribute Example Description <code>Bundle-ManifestVersion</code> 2 declares the OSGi bundle manifest version; always <code>2</code> <code>Bundle-Name</code> Awesome Data Source a concise human-readable name for the plugin <code>Bundle-SymbolicName</code> com.example.awesome a machine-readable, universally unique identifier for the plugin <code>Bundle-Version</code> 1.0.0 the plugin version <code>Bundle-RequiredExecutionEnvironment</code> JavaSE-1.8 a required OSGi execution environment"},{"location":"developers/osgi/manifest/#recommended-attributes","title":"Recommended attributes","text":"<p>Each plugin is recommended to provide the following attributes:</p> Attribute Example Description <code>Bundle-Description</code> An awesome data source that collects awesome data. a longer human-readable description of the plugin <code>Bundle-Vendor</code> ACME Corp the name of the entity or organisation that authored the plugin"},{"location":"developers/osgi/manifest/#common-attributes","title":"Common attributes","text":"<p>Other common manifest attributes are:</p> Attribute Example Description <code>Bundle-Activator</code> com.example.awesome.Activator a fully-qualified Java class name that implements the <code>org.osgi.framework.BundleActivator</code> interface, to handle plugin lifecycle events; see Activator for more information <code>Export-Package</code> net.solarnetwork.common.jdt;version=\"2.0.0\" a package export list <code>Import-Package</code> net.solarnetwork.service;version=\"[1.0,2.0)\" a package dependency list"},{"location":"developers/osgi/manifest/#package-dependencies","title":"Package dependencies","text":"<p>A plugin must declare the Java packages it directly uses in a <code>Import-Package</code> attribute. This attribute accpets a comma-delimited list of package specifications that take the basic form of:</p> <pre><code>PACKAGE;version=\"VERSION\"\n</code></pre> <p>For example here is how the <code>net.solarnetwork.service</code> package, versioned between <code>1.0</code> and <code>2.0</code>, would be declared:</p> <pre><code>Import-Package: net.solarnetwork.service;version=\"[1.0,2.0)\"\n</code></pre> <p>Direct package use means your plugin has code that imports a class from a given package. Classes in an imported package may import other packages indirectly; you do not need to import those packages as well.  For example if you have code like this:</p> <pre><code>import net.solarnetwork.service.OptionalService;\n</code></pre> <p>Then you will need to import the <code>net.solarnetwork.service</code> package.</p> <p>Note</p> <p>The SolarNode platform automatically imports core Java packages like <code>java.*</code> so you do not need to declare those.</p> <p>Also note that in some scenarios a package used by a class in an imported package becomes a direct dependency. For example when you extend a class from an imported package and that class imports other packages. Those other packages may become direct dependencies that you also need to import.</p>"},{"location":"developers/osgi/manifest/#child-package-dependencies","title":"Child package dependencies","text":"<p>If you import a package in your plugin, any child packages that may exist are not imported as well. You must import every individual package you need to use in your plugin.</p> <p>For example to use both <code>net.solarnetwork.service</code> and <code>net.solarnetwork.service.support</code> you would have an <code>Import-Package</code> attribute like this:</p> <pre><code>Import-Package:\nnet.solarnetwork.service;version=\"[1.0,2.0)\",\nnet.solarnetwork.service.support;version=\"[1.1,2.0)\"\n</code></pre>"},{"location":"developers/osgi/manifest/#package-exports","title":"Package exports","text":"<p>A plugin can export any package it provides, making the resources within that package available to other plugins to import and use. Declare exoprted packages with a <code>Export-Package</code> attribute. This attribute takes a comma-delimited list of versioned package specifications. Note that version ranges are not supported: you must declare the exact version of the package you are exporting. For example:</p> <pre><code>Export-Package: com.example.service;version=\"1.0.0\"\n</code></pre> <p>Note</p> <p>Exported packages should not be confused with services. Exported packages give other plugins access to the classes and any other resources within those packages, but do not provide services to the platform. You can use Blueprint to register services. Keep in mind that any service a plugin registers must exist within an exported package to be of any use.</p>"},{"location":"developers/services/backup-manager/","title":"Backup Manager","text":"<p>The <code>net.solarnetwork.node.backup.BackupManager</code> API provides SolarNode with a modular backup system composed of Backup Services that provide storage for backup data and Backup Resource Providers that contribute data to be backed up and support restoring backed up data.</p> <p>The Backup Manager coordinates the creation and restoration of backups, delegating most of its functionality to the active Backup Service. The active Backup Service can be controlled through configuration.</p> <p>The Backup Manager also supports exporting and importing Backup Archives, which are just <code>.zip</code> archives using a defined folder structure to preserve all backup resources within a single backup.</p> <p>This design of the SolarNode backup system makes it easy for SolarNode plugins to contribute resources to backups, without needing to know where or how the backup data is ultimately stored.</p> <p>What goes in a Backup?</p> <p>In SolarNode a Backup will contain all the critical settings that are unique to that node, such as:</p> <ol> <li>The node's security certificate</li> <li>SolarNetwork association details</li> <li>User accounts</li> <li>Settings</li> <li>and more</li> </ol>"},{"location":"developers/services/backup-manager/#configuration","title":"Configuration","text":"<p>The Backup Manager can be configured under the <code>net.solarnetwork.node.backup.DefaultBackupManager</code> configuration namespace:</p> Key Default Description <code>backupRestoreDelaySeconds</code> 15 A number of seconds to delay the attempt of restoring a backup, when a backup has been previously marked for restoration. This delay gives the platform time to boot up and register the backup resource providers and other services required to perform the restore. <code>preferredBackupServiceKey</code> net.solarnetwork.node.backup.FileSystemBackupService The key of the preferred (active) Backup Service to use."},{"location":"developers/services/backup-manager/#backup","title":"Backup","text":"<p>The <code>net.solarnetwork.node.backup.Backup</code> API defines a unique backup, created by a Backup Service. Backups are uniquely identified with a unique key assigned by the Backup Service that creates them.</p> <p>A <code>Backup</code> does not itself provide access to any of the resources associated with the backup. Instead, the <code>getBackupResources()</code> method of <code>BackupService</code> returns them.</p>"},{"location":"developers/services/backup-manager/#backup-archive","title":"Backup Archive","text":"<p>The Backup Manager supports exporting and importing specially formed <code>.zip</code> archives that contain a complete Backup. These archives are a convenient way to transfer settings from one node to another, and can be used to restore SolarNode on a new device.</p>"},{"location":"developers/services/backup-manager/#backup-resource","title":"Backup Resource","text":"<p>The <code>net.solarnetwork.node.backup.BackupResource</code> API defines a unique item within a Backup. A Backup Resource could be a file, a database table, or anything that can be serialized to a stream of bytes. Backup Resources are both provided by, and restored with, Backup Resource Providers so it is up to the Provider implementation to know how to generate and then restore the Resources it manages.</p>"},{"location":"developers/services/backup-manager/#backup-resource-provider","title":"Backup Resource Provider","text":"<p>The <code>net.solarnetwork.node.backup.BackupResourceProvider</code> API defines a service that can both generate and restore Backup Resources. Each implementation is identified by a unique key, typically the fully-qualified Java class name of the implementation.</p> <p>When a Backup is created, all Backup Resource Provider services registered in SolarNode will be asked to contribute their Backup Resources, using the <code>getBackupResources()</code> method.</p> <p>When a Backup is restored, Backup Resources will be passed to their associated Provider with the <code>restoreBackupResource(BackupResource)</code> method.</p>"},{"location":"developers/services/backup-manager/#backup-service","title":"Backup Service","text":"<p>The <code>net.solarnetwork.node.backup.BackupService</code> API defines the bulk of the SolarNode backup system. Each implementation is identified by a unique key, typically the fully-qualified Java class name of the implementation.</p> <p>To create a Backup, use the <code>performBackup(Iterable&lt;BackupResource&gt;)</code> method, passing in the collection of Backup Resources to include.</p> <p>To list the available Backups, use the <code>getAvailableBackups(Backup)</code> method.</p> <p>To view a single Backup, use the <code>backupForKey(String)</code> method.</p> <p>To list the resources in a Backup, use the <code>getBackupResources(Backup)</code>method.</p>"},{"location":"developers/services/backup-manager/#filesystembackupservice","title":"FileSystemBackupService","text":"<p>SolarNode provides the <code>net.solarnetwork.node.backup.FileSystemBackupService</code> default Backup Service implementation that saves Backup Archives to the node's own file system.</p>"},{"location":"developers/services/backup-manager/#s3backupservice","title":"S3BackupService","text":"<p>The <code>net.solarnetwork.node.backup.s3</code> plugin provides the <code>net.solarnetwork.node.backup.s3.S3BackupService</code> Backup Service implementation that saves all Backup data to AWS S3.</p>"},{"location":"developers/services/closeable-service/","title":"Closeable Service","text":"<p>A plugin can publish a <code>net.solarnetwork.service.CloseableService</code> and SolarNode will invoke the <code>closeService()</code> method on it when that service is destroyed. This can be useful in some situations, to make sure resources are freed when a service is no longer needed.</p> <p>Blueprint does provide the <code>destroy-method</code> stop hook that can be used in many situations, however Blueprint does not allow this in all cases. For example a <code>&lt;bean&gt;</code> nested within a <code>&lt;service&gt;</code> element does not allow a <code>destroy-method</code>:</p> <pre><code>&lt;service interface=\"com.example.MyService\"&gt;\n&lt;!-- destroy-method not allowed here: --&gt;\n&lt;bean class=\"com.example.MyComponent\"/&gt;\n&lt;/service&gt;\n</code></pre> <p>If <code>MyComponent</code> also implemented <code>CloseableService</code> then we can achieve the desired stop hook like this:</p> <pre><code>&lt;service&gt;\n&lt;interfaces&gt;\n&lt;value&gt;com.example.MyService&lt;/value&gt;\n&lt;value&gt;net.solarnetwork.service.CloseableService&lt;/value&gt;\n&lt;/interfaces&gt;\n&lt;bean class=\"com.example.MyComponent\"/&gt;\n&lt;/service&gt;\n</code></pre> <p>Note</p> <p>Note that the above example <code>CloseableService</code> is not strictly needed, as the same effect could be acheived by un-nesting the <code>&lt;bean&gt;</code> from the <code>&lt;service&gt;</code> element, like this:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\" destroy-method=\"close\"/&gt;\n&lt;service ref=\"myComponent\" interface=\"com.example.MyService\"/&gt;\n</code></pre> <p>There are situations where un-nesting is not possible, which is where <code>CloseableService</code> can be helpful.</p>"},{"location":"developers/services/datum-data-source-poll-job/","title":"Datum Data Source Poll Job","text":"<p>The <code>DatumDataSourcePollManagedJob</code> class is a Job Service implementation that can be used to let users schedule the generation of datum from a Datum Data Source. Typically this is configured as a Managed Service Factory so users can configure any number of job instances, each with their own settings.</p> <p>Here is a typical example of a <code>DatumDataSourcePollManagedJob</code>, in a fictional <code>MyDatumDataSource</code>:</p> MyDatumDataSource.javaMyDatumDataSource.properties LocalizationBlueprint XML <pre><code>package com.example;\n\nimport java.time.Instant;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport net.solarnetwork.domain.datum.DatumSamples;\nimport net.solarnetwork.node.domain.datum.EnergyDatum;\nimport net.solarnetwork.node.domain.datum.NodeDatum;\nimport net.solarnetwork.node.domain.datum.SimpleEnergyDatum;\nimport net.solarnetwork.node.service.DatumDataSource;\nimport net.solarnetwork.node.service.support.DatumDataSourceSupport;\nimport net.solarnetwork.settings.SettingSpecifier;\nimport net.solarnetwork.settings.SettingSpecifierProvider;\nimport net.solarnetwork.settings.SettingsChangeObserver;\nimport net.solarnetwork.settings.support.BasicTextFieldSettingSpecifier;\n\n/**\n * Super-duper datum data source.\n *\n * @author matt\n * @version 1.0\n */\npublic class MyDatumDataSource extends DatumDataSourceSupport\nimplements DatumDataSource, SettingSpecifierProvider, SettingsChangeObserver {\n\nprivate String sourceId;\nprivate int level;\n\n@Override\npublic Class&lt;? extends NodeDatum&gt; getDatumType() {\nreturn EnergyDatum.class;\n}\n\n@Override\npublic EnergyDatum readCurrentDatum() {\nfinal String sourceId = resolvePlaceholders(this.sourceId);\nif ( sourceId == null || sourceId.isEmpty() ) {\nreturn null;\n}\nSimpleEnergyDatum d = new SimpleEnergyDatum(sourceId, Instant.now(), new DatumSamples());\nd.setWatts(level);\nreturn d;\n}\n\n@Override\npublic void configurationChanged(Map&lt;String, Object&gt; properties) {\n// the settings have changed; do something\n}\n\n@Override\npublic String getSettingUid() {\nreturn \"com.example.MyDatumDataSource\";\n}\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nreturn Arrays.asList(new BasicTextFieldSettingSpecifier(\"sourceId\", null),\nnew BasicTextFieldSettingSpecifier(\"level\", String.valueOf(0)));\n}\n\npublic String getSourceId() {\nreturn sourceId;\n}\n\npublic void setSourceId(String sourceId) {\nthis.sourceId = sourceId;\n}\n\npublic int getLevel() {\nreturn level;\n}\n\npublic void setLevel(int level) {\nthis.level = level;\n}\n\n}\n</code></pre> <pre><code>title = Super-duper Datum Data Source\ndesc = This managed datum data source does it all.\n\nschedule.key = Schedule\nschedule.desc = The schedule to execute the job at. \\\nCan be either a number representing a frequency in &lt;b&gt;milliseconds&lt;/b&gt; \\\nor a &lt;a href=\"{0}\"&gt;cron expression&lt;/a&gt;, for example &lt;code&gt;0 * * * * *&lt;/code&gt;.\n\nsourceId.key = Source ID\nsourceId.desc = The source ID to use.\n\nlevel.key = Level\nlevel.desc = This one goes to 11.\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:osgix=\"http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\"\nxmlns:beans=\"http://www.springframework.org/schema/beans\"\nxsi:schemaLocation=\"\n        http://www.osgi.org/xmlns/blueprint/v1.0.0\n        http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium\n        http://www.eclipse.org/gemini/blueprint/schema/blueprint-compendium/gemini-blueprint-compendium.xsd\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n&lt;!-- Service References --&gt;\n\n&lt;bean id=\"datumMetadataService\" class=\"net.solarnetwork.common.osgi.service.DynamicServiceTracker\"&gt;\n&lt;argument ref=\"bundleContext\"/&gt;\n&lt;property name=\"serviceClassName\" value=\"net.solarnetwork.node.service.DatumMetadataService\"/&gt;\n&lt;property name=\"sticky\" value=\"true\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"datumQueue\" class=\"net.solarnetwork.common.osgi.service.DynamicServiceTracker\"&gt;\n&lt;argument ref=\"bundleContext\"/&gt;\n&lt;property name=\"serviceClassName\" value=\"net.solarnetwork.node.service.DatumQueue\"/&gt;\n&lt;property name=\"sticky\" value=\"true\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"placeholderService\" class=\"net.solarnetwork.common.osgi.service.DynamicServiceTracker\"&gt;\n&lt;argument ref=\"bundleContext\"/&gt;\n&lt;property name=\"serviceClassName\" value=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n&lt;property name=\"sticky\" value=\"true\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt;\n&lt;property name=\"basenames\" value=\"com.example.MyDatumDataSource\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"jobMessageSource\" class=\"net.solarnetwork.support.PrefixedMessageSource\"&gt;\n&lt;property name=\"prefix\" value=\"datumDataSource.\"/&gt;\n&lt;property name=\"delegate\" ref=\"messageSource\"/&gt;\n&lt;/bean&gt;\n\n&lt;!-- Managed Service Factory for Datum Data Source --&gt;\n\n&lt;service interface=\"net.solarnetwork.settings.SettingSpecifierProviderFactory\"&gt;\n&lt;bean class=\"net.solarnetwork.settings.support.BasicSettingSpecifierProviderFactory\"&gt;\n&lt;property name=\"displayName\" value=\"Super-duper Datum Data Source\"/&gt;\n&lt;property name=\"factoryUid\" value=\"com.example.MyDatumDataSource\"/&gt;&lt;!-- (1)! --&gt;\n&lt;property name=\"messageSource\" ref=\"messageSource\"/&gt;\n&lt;/bean&gt;\n&lt;/service&gt;\n\n&lt;osgix:managed-service-factory factory-pid=\"com.example.MyDatumDataSource\"\nautowire-on-update=\"true\" update-method=\"configurationChanged\"&gt;\n&lt;osgix:interfaces&gt;\n&lt;beans:value&gt;net.solarnetwork.node.job.ManagedJob&lt;/beans:value&gt;\n&lt;/osgix:interfaces&gt;\n&lt;bean class=\"net.solarnetwork.node.job.SimpleManagedJob\"\ninit-method=\"serviceDidStartup\" destroy-method=\"serviceDidShutdown\"&gt;\n&lt;argument&gt;\n&lt;bean class=\"net.solarnetwork.node.job.DatumDataSourcePollManagedJob\"&gt;\n&lt;property name=\"datumMetadataService\" ref=\"datumMetadataService\"/&gt;\n&lt;property name=\"datumQueue\" ref=\"datumQueue\"/&gt;\n&lt;property name=\"datumDataSource\"&gt;\n&lt;bean class=\"com.example.MyDatumDataSource\"&gt;&lt;!-- (2)! --&gt;\n&lt;property name=\"datumMetadataService\" ref=\"datumMetadataService\"/&gt;\n&lt;property name=\"messageSource\" ref=\"jobMessageSource\"/&gt;\n&lt;property name=\"placeholderService\" ref=\"placeholderService\"/&gt;\n&lt;/bean&gt;\n&lt;/property&gt;\n&lt;/bean&gt;\n&lt;/argument&gt;\n&lt;argument value=\"0 * * * * ?\"/&gt;\n&lt;property name=\"serviceProviderConfigurations\"&gt;&lt;!-- (3)! --&gt;\n&lt;map&gt;\n&lt;entry key=\"datumDataSource\"&gt;\n&lt;bean class=\"net.solarnetwork.node.job.SimpleServiceProviderConfiguration\"&gt;\n&lt;property name=\"interfaces\"&gt;\n&lt;list&gt;\n&lt;value&gt;net.solarnetwork.node.service.DatumDataSource&lt;/value&gt;\n&lt;/list&gt;\n&lt;/property&gt;\n&lt;property name=\"properties\"&gt;\n&lt;map&gt;\n&lt;entry key=\"datumClassName\" value=\"net.solarnetwork.node.domain.datum.EnergyDatum\"/&gt;\n&lt;/map&gt;\n&lt;/property&gt;\n&lt;/bean&gt;\n&lt;/entry&gt;\n&lt;/map&gt;\n&lt;/property&gt;\n&lt;/bean&gt;\n&lt;/osgix:managed-service-factory&gt;\n\n&lt;/blueprint&gt;\n</code></pre> <ol> <li>The <code>factoryUid</code> is the same value as the <code>getSettingsUid()</code> value in <code>MyDatumDataSource.java</code></li> <li>Hiding down here is our actual data source!</li> <li>Adding a service provider configuration is optional, but registers our data source as an    OSGi service, in addition to the <code>ManagedJob</code> that the Managed Service Factory registers.</li> </ol> <p>When this plugin is deployed in SolarNode, the managed component will appear on the main Settings page and then the component settings UI will look like this:</p> <p></p>"},{"location":"developers/services/datum-data-source/","title":"Datum Data Source","text":"<p>The <code>DatumDataSource</code> API defines the primary way for plugins to generate datum instances from devices or services integrated with SolarNode, through a request-based API. The <code>MultiDatumDataSource</code> API is closely related, and allows a plugin to generate multiple datum when requested.</p> DatumDataSourceMultiDatumDataSource <pre><code>package net.solarnetwork.node.service;\n\nimport net.solarnetwork.node.domain.datum.NodeDatum;\nimport net.solarnetwork.service.Identifiable;\n\n/**\n * API for collecting {@link NodeDatum} objects from some device.\n */\npublic interface DatumDataSource extends Identifiable, DeviceInfoProvider {\n\n/**\n     * Get the class supported by this DataSource.\n     *\n     * @return class\n     */\nClass&lt;? extends NodeDatum&gt; getDatumType();\n\n/**\n     * Read the current value from the data source, returning as an unpersisted\n     * {@link NodeDatum} object.\n     *\n     * @return Datum\n     */\nNodeDatum readCurrentDatum();\n\n}\n</code></pre> <pre><code>package net.solarnetwork.node.service;\n\nimport java.util.Collection;\nimport net.solarnetwork.node.domain.datum.NodeDatum;\nimport net.solarnetwork.service.Identifiable;\n\n/**\n * API for collecting multiple {@link NodeDatum} objects from some device.\n */\npublic interface MultiDatumDataSource extends Identifiable, DeviceInfoProvider {\n\n/**\n     * Get the class supported by this DataSource.\n     *\n     * @return class\n     */\nClass&lt;? extends NodeDatum&gt; getMultiDatumType();\n\n/**\n     * Read multiple values from the data source, returning as a collection of\n     * unpersisted {@link NodeDatum} objects.\n     *\n     * @return Datum\n     */\nCollection&lt;NodeDatum&gt; readMultipleDatum();\n\n}\n</code></pre> <p>The Datum Data Source Poll Job provides a way to let users schedule the polling for datum from a data source.</p>"},{"location":"developers/services/datum-db/","title":"Datum Database","text":"<p>TODO</p>"},{"location":"developers/services/datum-queue/","title":"Datum Queue","text":"<p>SolarNode has a <code>DatumQueue</code> service that acts as a central facility for processing all <code>NodeDatum</code> captured by all data source plugins deployed in the SolarNode runtime. The queue can be configured with various filters that can augment, modify, or discard the datum. The queue buffers the datum for a short amount of time and then processes them sequentially in order of time, oldest to newest.</p> <p>Datum data sources that use the Datum Data Source Poll Job are polled for datum on a recurring schedule and those datum are then posted to and stored in SolarNetwork. Data sources can also offer datum directly to the <code>DatumQueue</code> if they emit datum based on external events. When offering datum directly, the datum can be tagged as transient and they will then still be processed by the queue but will not be posted/stored in SolarNetwork.</p> <pre><code>/**\n * Offer a new datum to the queue, optionally persisting.\n *\n * @param datum\n *        the datum to offer\n * @param persist\n *        {@literal true} to persist, or {@literal false} to only pass to\n *        consumers\n * @return {@literal true} if the datum was accepted\n */\nboolean offer(NodeDatum datum, boolean persist);\n</code></pre>"},{"location":"developers/services/datum-queue/#queue-observer","title":"Queue observer","text":"<p>Plugins can also register observers on the <code>DatumQueue</code> that are notified of each datum that gets processed. The <code>addConsumer()</code> and <code>removeConsumer()</code> methods allow you to register/deregister observers:</p> <pre><code>/**\n * Register a consumer to receive processed datum.\n *\n * @param consumer\n *        the consumer to register\n */\nvoid addConsumer(Consumer&lt;NodeDatum&gt; consumer);\n\n/**\n * De-register a previously registered consumer.\n *\n * @param consumer\n *        the consumer to remove\n */\nvoid removeConsumer(Consumer&lt;NodeDatum&gt; consumer);\n</code></pre> <p>Each observer will receive all datum, including transient datum. An example plugin that makes use of this feature is the SolarFlux Upload Service, which posts a copy of each datum to a MQTT server.</p> <p>Here is a screen shot of the datum queue settings available in the SolarNode UI:</p> <p></p>"},{"location":"developers/services/job-scheduler/","title":"Job Scheduler","text":"<p>SolarNode provides a ManagedJobScheduler service that can automatically execute jobs exported by plugins that have user-defined schedules.</p> <p>The Job Scheduler uses the Task Scheduler</p> <p>The Job Scheduler service uses the Task Scheduler internally, which means the number of jobs that can execute simultaneously will be limited by its thread pool configuration.</p>"},{"location":"developers/services/job-scheduler/#managed-jobs","title":"Managed Jobs","text":"<p>Any plugin simply needs to register a ManagedJob service for the Job Scheduler to automatically schedule and execute the job. The schedule is provided by the <code>getSchedle()</code> method, which can return a cron expression or a plain number representing a millisecond period.</p> <p>The <code>net.solarnetwork.node.job.SimpleManagedJob</code> class implements <code>ManagedJob</code> and can be used in most situations. It delegates the actual work to a <code>net.solarnetwork.node.job.JobService</code> API, discussed in the next section.</p>"},{"location":"developers/services/job-scheduler/#job-service","title":"Job Service","text":"<p>The <code>ManagedJob</code> API delegates the actual task work to a <code>JobService</code> API. The <code>executeJobService()</code> method will be invoked when the job executes.</p>"},{"location":"developers/services/job-scheduler/#example-managed-job","title":"Example Managed Job","text":"<p>Let's imagine you have a <code>com.example.Job</code> class that you would like to allow users to schedule. Your class would implement the <code>JobService</code> interface, and then you would provide a localized messages properties file and configure the service using OSGi Blueprint.</p> com.example.Job.javacom.example.Job.propertiesOSGi Blueprint <pre><code>package com.example;\n\nimport java.util.Collections;\nimport java.util.List;\nimport net.solarnetwork.node.job.JobService;\nimport net.solarnetwork.node.service.support.BaseIdentifiable;\nimport net.solarnetwork.settings.SettingSpecifier;\n\n/**\n * My super-duper job.\n */\npublic class Job exetnds BaseIdentifiable implements JobService {\n@Override\npublic String getSettingUid() {\nreturn \"com.example.job\"; // (1)!\n}\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nreturn Collections.emptyList(); // (2)!\n}\n\n@Override\npublic void executeJobService() throws Exception {\n// do great stuff here!\n}\n}\n</code></pre> <ol> <li>The setting UID will be configured in the Blueprint XML as well.</li> <li>The <code>SimpleManagedJob</code> class we'll configure in Blueprint XML will automatically    add a <code>schedule</code> setting to configure the job schedule.</li> </ol> <pre><code>title = Super-duper Job\ndesc = This job does it all.\n\nschedule.key = Schedule\nschedule.desc = The schedule to execute the job at. \\\nCan be either a number representing a frequency in &lt;b&gt;milliseconds&lt;/b&gt; \\\nor a &lt;a href=\"{0}\"&gt;cron expression&lt;/a&gt;, for example &lt;code&gt;0 * * * * *&lt;/code&gt;.\n</code></pre> <pre><code>&lt;service interface=\"net.solarnetwork.node.job.ManagedJob\"&gt;&lt;!-- (1)! --&gt;\n&lt;service-properties&gt;\n&lt;entry key=\"service.pid\" value=\"com.example.job\"/&gt;\n&lt;/service-properties&gt;\n&lt;bean class=\"net.solarnetwork.node.job.SimpleManagedJob\"&gt;&lt;!-- (2)! --&gt;\n&lt;argument&gt;\n&lt;bean class=\"com.example.Job\"&gt;\n&lt;property name=\"uid\" value=\"com.example.job\"/&gt;&lt;!-- (3)! --&gt;\n&lt;property name=\"messageSource\"&gt;\n&lt;bean class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt;\n&lt;property name=\"basenames\" value=\"com.example.Job\"/&gt;\n&lt;/bean&gt;\n&lt;/property&gt;\n&lt;/bean&gt;\n&lt;/argument&gt;\n&lt;property name=\"schedule\" value=\"0 * * * * *\"/&gt;\n&lt;/bean&gt;\n&lt;/service&gt;\n</code></pre> <ol> <li>This registers a <code>ManagedJob</code> service with the SolarNode runtime.</li> <li>The <code>SimpleManagedJob</code> class is a handy <code>ManagedJob</code> implementation. It adds a <code>schedule</code>    setting to any settings returned by the <code>JobService</code>.</li> <li>The <code>uid</code> value should match the <code>service.pid</code> used earlier, which matches the value    returned by the <code>getSettingUid()</code> method in the <code>Job</code> class.</li> </ol> <p>When this plugin is deployed in SolarNode, the component will appear on the main Settings page and offer a configurable Schedule setting, like this:</p> <p></p>"},{"location":"developers/services/placeholder-service/","title":"Placeholder Service","text":"<p>The Placeholder Service API provides components a way to resolve variables in strings, known as placeholders, whose values are managed outside the component itself. For example a datum data source plugin could use the Placeholder Service to support resolving placeholders in a configurable Source ID property.</p> <p>SolarNode provides a Placeholder Service implementation that resolves both dynamic placeholders from the Settings Database (using the setting namespace <code>placeholder</code>), and static placeholders from a configurable file or directory location.</p>"},{"location":"developers/services/placeholder-service/#use","title":"Use","text":"<p>Call the <code>resolvePlaceholders(s, parameters)</code> method to resolve all placeholders on the String <code>s</code>. The <code>parameters</code> argument can be used to provide additional placeholder values, or you can pass just pass <code>null</code> to rely solely on the placeholders available in the service already.</p>"},{"location":"developers/services/placeholder-service/#example","title":"Example","text":"<p>Here is an imaginary class that is constructed with an optional <code>PlaceholderService</code>, and then when the <code>go()</code> method is called uses that to resolve placeholders in the string <code>{building}/temp</code> and return the result:</p> <pre><code>package com.example;\n\nimport net.solarnetwork.node.service.PlaceholderService;\nimport net.solarnetwork.service.OptionalService;\n\npublic class MyComponent {\n\nprivate final OptionalService&lt;PlaceholderService&gt; placeholderService;\n\npublic MyComponent(OptionalService&lt;PlaceholderService&gt; placeholderService) {\nsuper();\nthis.placeholderService = placeholderService;\n}\n\npublic String go() {\nreturn PlaceholderService.resolvePlaceholders(placeholderService,\n\"{building}/temp\", null);\n}\n}\n</code></pre>"},{"location":"developers/services/placeholder-service/#blueprint","title":"Blueprint","text":"<p>To use the Placeholder Service in your component, add either an Optional Service or explicit reference to your plugin's Blueprint XML file like this (depending on what your plugin requires):</p> Optional ServiceExplicit Reference <pre><code>&lt;bean id=\"placeholderService\" class=\"net.solarnetwork.common.osgi.service.DynamicServiceTracker\"&gt;\n&lt;argument ref=\"bundleContext\"/&gt;\n&lt;property name=\"serviceClassName\" value=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n&lt;property name=\"sticky\" value=\"true\"/&gt;\n&lt;/bean&gt;\n</code></pre> <pre><code>&lt;reference id=\"placeholderService\" interface=\"net.solarnetwork.node.service.PlaceholderService\"/&gt;\n</code></pre> <p>Then inject that service into your component's <code>&lt;bean&gt;</code>, for example:</p> <pre><code>&lt;bean id=\"myComponent\" class=\"com.example.MyComponent\"&gt;\n&lt;argument ref=\"placeholderService\"&gt;\n&lt;/bean&gt;\n</code></pre>"},{"location":"developers/services/placeholder-service/#configuration","title":"Configuration","text":"<p>The Placeholder Service supports the following configuration properties in the <code>net.solarnetwork.node.core</code> namespace:</p> Property Default Description <code>placeholders.dir</code> ${CONF_DIR}/placeholders.d Path to a single propertites file or to a directory of properties files to load as static placeholder parameter values when SolarNode starts up."},{"location":"developers/services/settings-db/","title":"Settings Database","text":""},{"location":"developers/services/settings-service/","title":"Settings Service","text":"<p>TODO</p>"},{"location":"developers/services/sql-database/","title":"SQL Database","text":"<p>The SolarNode runtime provides a local SQL database that is used to hold application settings, data sampled from devices, or anything really. Some data is designed to live only in this local store (such as settings) while other data eventually gets pushed up into the SolarNet cloud. This document describes the most common aspects of the local database.</p>"},{"location":"developers/services/sql-database/#database-implementation","title":"Database implementation","text":"<p>The database is provided by either the H2 or Apache Derby embedded SQL database engine.</p> <p>Note</p> <p>In SolarNodeOS the solarnode-app-db-h2 and solarnode-app-db-derby packages provide the H2 and Derby database implementations. Most modern SolarNode deployments use H2.</p> <p>Typically the database is configured to run entirely within RAM on devices that support it, and the RAM copy is periodically synced to non-volatile media so if the device restarts the persisted copy of the database can be loaded back into RAM. This pattern works well because:</p> <ol> <li>Non-volatile media access can be slow (e.g. flash memory)</li> <li>Non-volatile media can wear out over time from many writes (e.g. flash memory)</li> <li>Aside from settings, which change infrequently, most data stays locally only a     short time before getting pushed into the SolarNet cloud.</li> </ol>"},{"location":"developers/services/sql-database/#low-level-access-jdbc","title":"Low level access: JDBC","text":"<p>A standard JDBC stack is available and normal SQL queries are used to access the database. The Hikari JDBC connection pool provides a <code>javax.sql.DataSource</code> for direct JDBC access. The pool is configured by factory configuration files in the <code>net.solarnetwork.jdbc.pool.hikari</code> namespace. See the net.solarnetwork.jdbc.pool.hikari-solarnode.cfg as an example.</p> <p>To make use of the <code>DataSource</code> from a plugin using OSGi Blueprint you can declare a reference like this:</p> <pre><code>&lt;reference id=\"dataSource\" interface=\"javax.sql.DataSource\" filter=\"(db=node)\" /&gt;\n</code></pre> <p>The net.solarnetwork.node.dao.jdbc bundle publishes some other JDBC services for plugins to use, such as:</p> <ul> <li>A Spring <code>org.springframework.jdbc.core.JdbcOperations</code> for slightly higher-level JDBC access</li> <li>A Spring <code>org.springframework.transaction.PlatformTransactionManager</code> for JDBC transaction    support</li> </ul> <p>To make use of these from a plugin using OSGi Blueprint you can declare references to these APIs like this:</p> <pre><code>&lt;reference id=\"jdbcOps\" interface=\"org.springframework.jdbc.core.JdbcOperations\"\nfilter=\"(db=node)\" /&gt;\n\n&lt;reference id=\"txManager\" interface=\"org.springframework.transaction.PlatformTransactionManager\"\nfilter=\"(db=node)\" /&gt;\n</code></pre>"},{"location":"developers/services/sql-database/#high-level-access-data-access-object-dao","title":"High level access: Data Access Object (DAO)","text":"<p>The SolarNode runtime also provides some Data Access Object (DAO) services that make storing some typical data easier:</p> <ul> <li>A <code>net.solarnetwork.node.dao.SettingDao</code> for access to the Settings Database</li> <li>A <code>net.solarnetwork.node.dao.DatumDao</code> for access to the Datum Database</li> </ul> <p>To make use of these from a plugin using OSGi Blueprint you can declare references to these APIs like this:</p> <pre><code>&lt;reference id=\"settingDao\" interface=\"net.solarnetwork.node.dao.SettingDao\"/&gt;\n\n&lt;reference id=\"datumDao\" interface=\"net.solarnetwork.node.dao.DatumDao\"/&gt;\n</code></pre>"},{"location":"developers/services/task-executor/","title":"Task Executor","text":"<p>To support asynchronous task execution, SolarNode makes several thread-pool based services available to plugins:</p> <ul> <li>A <code>java.util.concurrent.Executor</code> service for standard <code>Runnable</code> task execution</li> <li>A Spring <code>TaskExecutor</code> service for <code>Runnable</code> task execution</li> <li>A Spring <code>AsyncTaskExecutor</code> service for both <code>Runnable</code> and <code>Callable</code> task execution</li> <li>A Spring <code>AsyncListenableTaskExecutor</code> service for both <code>Runnable</code>   and <code>Callable</code> task execution that supports the   <code>org.springframework.util.concurrent.ListenableFuture</code> API</li> </ul> <p>Need to schedule tasks?</p> <p>See the Task Scheduler page for information on scheduling simple tasks, or the Job Scheduler page for information on scheduling managed jobs.</p> <p>To make use of any of these services from a plugin using OSGi Blueprint you can declare a reference to them like this:</p> <pre><code>&lt;reference id=\"taskExecutor\" interface=\"java.util.concurrent.Executor\"\nfilter=\"(function=node)\"/&gt;\n\n&lt;reference id=\"taskExecutor\" interface=\"org.springframework.core.task.TaskExecutor\"\nfilter=\"(function=node)\"/&gt;\n\n&lt;reference id=\"taskExecutor\" interface=\"org.springframework.core.task.AsyncTaskExecutor\"\nfilter=\"(function=node)\"/&gt;\n\n&lt;reference id=\"taskExecutor\" interface=\"org.springframework.core.task.AsyncListenableTaskExecutor\"\nfilter=\"(function=node)\"/&gt;\n</code></pre>"},{"location":"developers/services/task-executor/#thread-pool-configuration","title":"Thread pool configuration","text":"<p>This thread pool is configured as a fixed-size pool with the number of threads set to the number of CPU cores detected at runtime, plus one. For example on a Raspberry Pi 4 there are 4 CPU cores so the thread pool would be configured with 5 threads.</p>"},{"location":"developers/services/task-scheduler/","title":"Task Scheduler","text":"<p>To support asynchronous task scheduling, SolarNode provides a Spring TaskScheduler service to plugins.</p> <p>The Job Scheduler</p> <p>For user-configurable scheduled tasks, check out the Job Scheduler service.</p> <p>To make use of any of this service from a plugin using OSGi Blueprint you can declare a reference like this:</p> <pre><code>&lt;reference id=\"taskScheduler\" interface=\"org.springframework.scheduling.TaskScheduler\"\nfilter=\"(function=node)\"/&gt;\n</code></pre>"},{"location":"developers/services/task-scheduler/#configuration","title":"Configuration","text":"<p>The Task Scheduler supports the following configuration properties in the <code>net.solarnetwork.node.core</code> namespace:</p> Property Default Description <code>jobScheduler.poolSize</code> 10 The number of threads to maintain in the job scheduler, and thus the maximum number of jobs that can run simultaneously. Must be set to 1 or higher. <code>scheduler.startupDelay</code> 180 A delay in seconds after creating the job scheduler to start triggering jobs. This can be useful to give the application time to completely initialize before starting to run jobs. <p>For example, to change the thread pool size to 20 and shorten the startup delay to 30 seconds, create an <code>/etc/solarnode/services/net.solarnetwork.node.core.cfg</code> file with the following content:</p> <pre><code>jobScheduler.poolSize = 20\nscheduler.startupDelay = 30\n</code></pre>"},{"location":"developers/settings/","title":"Settings","text":"<p>SolarNode provides a way for plugin components to describe their user-configurable properties, called settings, to the platform. SolarNode provides a web-based GUI that makes it easy for users to configure those components using a web browser. For example, here is a screen shot of the SolarNode GUI showing a form for the settings of a Database Backup component:</p> <p></p> <p>The mechanism for components to describe themselves in this way is called the Settings API. Classes that wish to participate in this system publish metadata about their configurable properties through the Settings Provider API, and then SolarNode generates a GUI form based on that metadata. Each form field in the previous example image is a Setting Specifier.</p> <p>The process is similar to the built-in Settings app on iOS: iOS applications can publish configurable property definitions and the Settings app displays a GUI that allows users to modify those properties.</p>"},{"location":"developers/settings/factory/","title":"Factory Service","text":""},{"location":"developers/settings/provider/","title":"Settings Provider","text":"<p>The <code>net.solarnetwork.settings.SettingSpecifierProvider</code> interface defines the way a class can declare themselves as a user-configurable component. The main elements of this API are:</p> <pre><code>public interface SettingSpecifierProvider {\n\n/**\n     * Get a unique, application-wide setting ID.\n     *\n     * @return unique ID\n     */\nString getSettingUid();\n\n/**\n     * Get a non-localized display name.\n     *\n     * @return non-localized display name\n     */\nString getDisplayName();\n\n/**\n     * Get a list of {@link SettingSpecifier} instances.\n     *\n     * @return list of {@link SettingSpecifier}\n     */\nList&lt;SettingSpecifier&gt; getSettingSpecifiers();\n\n}\n</code></pre> <p>The <code>getSettingUid()</code> method defines a unique ID for the configurable component. By convention the class or package name of the component (or a derivative of it) is used as the ID.</p> <p>The <code>getSettingSpecifiers()</code> method returns a list of all the configurable properties of the component, as a list of Setting Specifier instances.</p>"},{"location":"developers/settings/provider/#setting-accessors","title":"Setting accessors","text":"<p>s <pre><code>@Override\nprivate String username;\n\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;(1);\n\n// expose a \"username\" setting with a default value of \"admin\"\nresults.add(new BasicTextFieldSettingSpecifier(\"username\", \"admin\"));\n\nreturn results;\n}\n\n// settings are updated at runtime via standard setter methods\npublic void setUsername(String username) {\nthis.username = username;\n}\n</code></pre></p> <p>Setting values are treated as strings within the Settings API, but the methods associated with settings can accept any primitive or standard number type like <code>int</code> or <code>Integer</code> as well.</p> BigDecimal setting example<pre><code>@Override\nprivate BigDecimal num;\n\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;(1);\n\nresults.add(new BasicTextFieldSettingSpecifier(\"num\", null));\n\nreturn results;\n}\n\n// settings will be coerced from strings into basic types automatically\npublic void setNum(BigDecimal num) {\nthis.num = num;\n}\n</code></pre>"},{"location":"developers/settings/provider/#proxy-setting-accessors","title":"Proxy setting accessors","text":"<p>Sometimes you might like to expose a simple string setting but internally treat the string as a more complex type. For example a <code>Map</code> could be configured using a simple delimited string like <code>key1 = val1, key2 = val2</code>. For situations like this you can publish a proxy setting that manages a complex data type as a string, and en/decode the complex type in your component accessor methods.</p> Delimited string to Map setting example<pre><code>@Override\nprivate Map&lt;String, String&gt; map;\n\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;(1);\n\n// expose a \"mapping\" proxy setting for the map field\nresults.add(new BasicTextFieldSettingSpecifier(\"mapping\", null));\n\nreturn results;\n}\n\npublic void setMapping(String mapping) {\nthis.map = StringUtils.commaDelimitedStringToMap(mapping);\n}\n</code></pre>"},{"location":"developers/settings/resource-handler/","title":"Setting Resource Handler","text":"<p>The <code>net.solarnetwork.node.settings.SettingResourceHandler</code> API defines a way for a component to import and export files uploaded to SolarNode from external sources.</p> <p>A component could support importing a file using the File setting. This could be used, to provide a way of configuring the component from a configuration file, like CSV, JSON, XML, and so on. Similarly a component could support exporting a file, to generate a configuration file in another format like CSV, JSON, XML, and so on, from its current settings. For example, the Modbus Device Datum Source does exactly these things: importing and exporting a custom CSV file to make configuring the component easier.</p>"},{"location":"developers/settings/resource-handler/#importing","title":"Importing","text":"<p>The main part of the <code>SettingResourceHandler</code> API for importing files looks like this:</p> <pre><code>public interface SettingResourceHandler {\n\n/**\n     * Get a unique, application-wide setting ID.\n     *\n     * &lt;p&gt;\n     * This ID must be unique across all setting resource handlers registered\n     * within the system. Generally the implementation will also be a\n     * {@link net.solarnetwork.settings.SettingSpecifierProvider} for the same\n     * ID.\n     * &lt;/p&gt;\n     *\n     * @return unique ID\n     */\nString getSettingUid();\n\n/**\n     * Apply settings for a specific key from a resource.\n     *\n     * @param settingKey\n     *        the setting key, generally a\n     *        {@link net.solarnetwork.settings.KeyedSettingSpecifier#getKey()}\n     *        value\n     * @param resources\n     *        the resources with the settings to apply\n     * @return any setting values that should be persisted as a result of\n     *         applying the given resources (never {@literal null}\n     * @throws IOException\n     *         if any IO error occurs\n     */\nSettingsUpdates applySettingResources(String settingKey, Iterable&lt;Resource&gt; resources)\nthrows IOException;\n</code></pre> <p>The <code>getSettingUid()</code> method overlaps with the Settings Provider API, and as the comments note it is typical for a Settings Provider that publishes settings like File or Text Area to also implement <code>SettingResourceHandler</code>.</p> <p>The <code>settingKey</code> passed to the <code>applySettingResources()</code> method identifies the resource(s) being uploaded, as a single Setting Resource Handler might support multiple resources. For example a Settings Provider might publish multiple File settings, or File and Text Area settings. The <code>settingKey</code> is used to differentiate between each one.</p>"},{"location":"developers/settings/resource-handler/#importing-example","title":"Importing example","text":"<p>Imagine a component that publishes a File setting. A typical implementation of that component would look like this (this example omits some methods for brevity):</p> <pre><code>public class MyComponent implements SettingSpecifierProvider,\nSettingResourceHandler {\n\nprivate static final Logger log\n= LoggerFactory.getLogger(MyComponent.class);\n\n/** The resource key to identify the File setting resource. */\npublic static final String RESOURCE_KEY_DOCUMENT = \"document\";\n\n@Override\npublic String getSettingUid() {\nreturn \"com.example.mycomponent\";\n}\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;();\n\n// publish a File setting tied to the RESOURCE_KEY_DOCUMENT key,\n// allowing only text files to be accepted\nresults.add(new BasicFileSettingSpecifier(RESOURCE_KEY_DOCUMENT, null,\nnew LinkedHashSet&lt;&gt;(asList(\".txt\", \"text/*\")), false));\n\nreturn results;\n}\n\n@Override\npublic SettingsUpdates applySettingResources(String settingKey,\nIterable&lt;Resource&gt; resources) throws IOException {\nif ( resources == null ) {\nreturn null;\n}\nif ( RESOURCE_KEY_DOCUMENT.equals(settingKey) ) {\nfor ( Resource r : resources ) {\n// here we would do something useful with the resource... like\n// read into a string and log it\nString s = FileCopyUtils.copyToString(new InputStreamReader(\nr.getInputStream(), StandardCharsets.UTF_8));\n\nlog.info(\"Got {} resource content: {}\", settingKey, s);\n\nbreak; // only accept one file\n}\n}\nreturn null;\n}\n\n}\n</code></pre>"},{"location":"developers/settings/resource-handler/#exporting","title":"Exporting","text":"<p>The part of the Setting Resource Handler API that supports exporting setting resources looks like this:</p> <pre><code>    /**\n     * Get a list of supported setting keys for the\n     * {@link #currentSettingResources(String)} method.\n     *\n     * @return the set of supported keys\n     */\ndefault Collection&lt;String&gt; supportedCurrentResourceSettingKeys() {\nreturn Collections.emptyList();\n}\n\n/**\n     * Get the current setting resources for a specific key.\n     *\n     * @param settingKey\n     *        the setting key, generally a\n     *        {@link net.solarnetwork.settings.KeyedSettingSpecifier#getKey()}\n     *        value\n     * @return the resources, never {@literal null}\n     */\nIterable&lt;Resource&gt; currentSettingResources(String settingKey);\n</code></pre> <p>The <code>supportedCurrentResourceSettingKeys()</code> method returns a set of resource keys the component supports for exporting. The <code>currentSettingResources()</code> method returns the resources to export for a given key.</p> <p>The SolarNode GUI shows a form menu with all the available resources for all components that support the <code>SettingResourceHandler</code> API, and lets the user to download them:</p> <p></p>"},{"location":"developers/settings/resource-handler/#exporting-example","title":"Exporting example","text":"<p>Here is an example of a component that supports exporting a CSV file resource based on the component's current configuration:</p> <pre><code>public class MyComponent implements SettingSpecifierProvider,\nSettingResourceHandler {\n\n/** The setting resource key for a CSV configuration file. */\npublic static final String RESOURCE_KEY_CSV_CONFIG = \"csvConfig\";\n\nprivate int max = 1;\nprivate boolean enabled = true;\n\n@Override\npublic Collection&lt;String&gt; supportedCurrentResourceSettingKeys() {\nreturn Collections.singletonList(RESOURCE_KEY_CSV_CONFIG);\n}\n\n@Override\npublic Iterable&lt;Resource&gt; currentSettingResources(String settingKey) {\nif ( !RESOURCE_KEY_CSV_CONFIG.equals(settingKey) ) {\nreturn null;\n}\n\nStringBuilder buf = new StringBuilder();\nbuf.append(\"max,enabled\\r\\n\");\nbuf.append(max).append(',').append(enabled).append(\"\\r\\n\");\n\nreturn Collections.singleton(new ByteArrayResource(\nbuf.toString().getBytes(UTF_8), \"My Component CSV Config\") {\n\n@Override\npublic String getFilename() {\nreturn \"my-component-config.csv\";\n}\n\n});\n}\n}\n</code></pre>"},{"location":"developers/settings/singleton/","title":"Singleton Service","text":""},{"location":"developers/settings/specifier/","title":"Setting Specifier","text":"<p>The <code>net.solarnetwork.settings.SettingSpecifier</code> API defines metadata for a single configurable property in the Settings API. The API looks like this:</p> <pre><code>public interface SettingSpecifier {\n\n/**\n     * A unique identifier for the type of setting specifier this represents.\n     *\n     * &lt;p&gt;\n     * Generally this will be a fully-qualified interface name.\n     * &lt;/p&gt;\n     *\n     * @return the type\n     */\nString getType();\n\n/**\n     * Localizable text to display with the setting's content.\n     *\n     * @return the title\n     */\nString getTitle();\n\n}\n</code></pre> <p>This interface is very simple, and extended by more specialized interfaces that form more useful setting types.</p> <p>Note</p> <p>A <code>SettingSpecifier</code> instance is often referred to simply as a setting.</p> <p>Here is a view of the class hierarchy that builds off of this interface:</p> <p></p> <p>Note</p> <p>The <code>SettingSpecifier</code> API defines metadata about a configurable property, but not methods to view or change that property's value. The Settings Service provides methods for managing setting values.</p>"},{"location":"developers/settings/specifier/#settings-playpen","title":"Settings Playpen","text":"<p>The Settings Playpen plugin demonstrates most of the available setting types, and is a great way to see how the settings can be used.</p>"},{"location":"developers/settings/specifier/#text-field","title":"Text Field","text":"<p>The <code>TextFieldSettingSpecifier</code> defines a simple string-based configurable property and is the most common setting type. The setting defines a <code>key</code> that maps to a setter method on its associated component class. In the SolarNode GUI a text field is rendered as an HTML form text input, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicTextFieldSettingSpecifier</code> class provides the standard implementation of this API. A standard text field setting is created like this:</p> <pre><code>new BasicTextFieldSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\");\n\n// or without any default value\nnew BasicTextFieldSettingSpecifier(\"myProperty\", null);\n</code></pre> <p>Tip</p> <p>Setting values are generally treated as strings within the Settings API, however other basic data types such as integers and numbers can be used as well. You can also publish a \"proxy\" setting that manages a complex data type as a string, and en/decode the complex type in your component accessor methods.</p> <p>For example a <code>Map&lt;String, String&gt;</code> setting could be published as a text field setting that en/decodes the <code>Map</code> into a delimited string value, for example <code>name=Test, color=red</code>.</p>"},{"location":"developers/settings/specifier/#secure-text-field","title":"Secure Text Field","text":"<p>The <code>BasicTextFieldSettingSpecifier</code> can also be used for \"secure\" text fields where the field's content is obscured from view. In the SolarNode GUI a secure text field is rendered as an HTML password form input like this:</p> <p></p> <p>A standard secure text field setting is created by passing a third <code>true</code> argument, like this:</p> <pre><code>new BasicTextFieldSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\", true);\n\n// or without any default value\nnew BasicTextFieldSettingSpecifier(\"myProperty\", null, true);\n</code></pre>"},{"location":"developers/settings/specifier/#title","title":"Title","text":"<p>The <code>TitleSettingSpecifier</code> defines a simple read-only string-based configurable property. The setting defines a <code>key</code> that maps to a setter method on its associated component class. In the SolarNode GUI the default value is rendered as plain text, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicTitleSettingSpecifier</code> class provides the standard implementation of this API. A standard title setting is created like this:</p> <pre><code>new BasicTitleSettingSpecifier(\"status\", \"Status is good.\", true);\n</code></pre>"},{"location":"developers/settings/specifier/#html-title","title":"HTML Title","text":"<p>The <code>TitleSettingSpecifier</code> supports HTML markup. In the SolarNode GUI the default value is rendered directly into HTML, like this:</p> <p></p> <pre><code>// pass `true` as the 4th argument to enable HTML markup in the status value\nnew BasicTitleSettingSpecifier(\"status\", \"Status is &lt;b&gt;good&lt;/b&gt;.\", true, true);\n</code></pre>"},{"location":"developers/settings/specifier/#text-area","title":"Text Area","text":"<p>The <code>TextAreaSettingSpecifier</code> defines a simple string-based configurable property for a larger text value, loaded as an external file using the SettingResourceHandler API. In the SolarNode GUI a text area is rendered as an HTML form text area with an associated button to upload the content, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicTextAreaSettingSpecifier</code> class provides the standard implementation of this API. A standard text field setting is created like this:</p> <pre><code>new BasicTextAreaSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\");\n\n// or without any default value\nnew BasicTextAreaSettingSpecifier(\"myProperty\", null);\n</code></pre>"},{"location":"developers/settings/specifier/#direct-text-area","title":"Direct Text Area","text":"<p>The <code>BasicTextAreaSettingSpecifier</code> can also be used for \"direct\" text areas where the field's content is not uploaded as an external file. In the SolarNode GUI a direct text area is rendered as an HTML form text area, like this:</p> <p></p> <p>A standard direct text area setting is created by passing a third <code>true</code> argument, like this:</p> <pre><code>new BasicTextAreaSettingSpecifier(\"myProperty\", \"DEFAULT_VALUE\", true);\n\n// or without any default value\nnew BasicTextAreaSettingSpecifier(\"myProperty\", null, true);\n</code></pre>"},{"location":"developers/settings/specifier/#toggle","title":"Toggle","text":"<p>The <code>ToggleSettingSpecifier</code> defines a boolean configurable property. In the SolarNode GUI a toggle setting is rendered as an HTML form button, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicToggleSettingSpecifier</code> class provides the standard implementation of this API. A standard toggle setting is created like this:</p> <pre><code>new BasicToggleSettingSpecifier(\"enabled\", false); // default \"off\"\n\nnew BasicToggleSettingSpecifier(\"enabled\", true);  // default \"on\"\n</code></pre>"},{"location":"developers/settings/specifier/#slider","title":"Slider","text":"<p>The <code>SliderSettingSpecifier</code> defines a number-based configuration property with minimum and maximum values enforced, and a step limit. In the SolarNode GUI a slider is rendered as an HTML widget, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicSliderSettingSpecifier</code> class provides the standard implementation of this API. A standard Slider setting is created like this:</p> <pre><code>// no default value, range between 0-11 in 0.5 increments\nnew BasicSliderSettingSpecifier(\"volume\", null, 0.0, 11.0, 0.5);\n\n// default value 5.0, range between 0-11 in 0.5 increments\nnew BasicSliderSettingSpecifier(\"volume\", 5.0, 0.0, 11.0, 0.5);\n</code></pre>"},{"location":"developers/settings/specifier/#radio-group","title":"Radio Group","text":"<p>The <code>RadioGroupSettingSpecifier</code> defines a configurable property that accepts a single value from a fixed set of possible values. In the SolarNode GUI a radio group is rendered as a set of HTML radio input form fields, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicRadioGroupSettingSpecifier</code> class provides the standard implementation of this API. A standard RadioGroup setting is created like this:</p> <pre><code>String[] vals = new String[] {\"a\", \"b\", \"c\"};\nString[] labels = new Strign[] {\"One\", \"Two\", \"Three\"};\nMap&lt;String, String&gt; radioValues = new LinkedHashMap&lt;&gt;(3);\nfor ( int i = 0; i &lt; vals.length; i++ ) {\nradioValues.put(vals[i], labels[i]);\n}\nBasicRadioGroupSettingSpecifier radio =\nnew BasicRadioGroupSettingSpecifier(\"option\", vals[0]);\nradio.setValueTitles(radioValues);\n</code></pre>"},{"location":"developers/settings/specifier/#multi-value","title":"Multi-value","text":"<p>The <code>MultiValueSettingSpecifier</code> defines a configurable property that accepts a single value from a fixed set of possible values. In the SolarNode GUI a multi-value setting is rendered as an HTML select form field, like this:</p> <p></p> <p>The <code>net.solarnetwork.settings.support.BasicMultiValueSettingSpecifier</code> class provides the standard implementation of this API. A standard MultiValue setting is created like this:</p> <pre><code>String[] vals = new String[] {\"a\", \"b\", \"c\"};\nString[] labels = new Strign[] {\"Option 1\", \"Option 2\", \"Option 3\"};\nMap&lt;String, String&gt; radioValues = new LinkedHashMap&lt;&gt;(3);\nfor ( int i = 0; i &lt; vals.length; i++ ) {\nradioValues.put(vals[i], labels[i]);\n}\nBasicMultiValueSettingSpecifier menu = new BasicMultiValueSettingSpecifier(\"option\",\nvals[0]);\nmenu.setValueTitles(menuValues);\n</code></pre>"},{"location":"developers/settings/specifier/#file","title":"File","text":"<p>The <code>FileSettingSpecifier</code> defines a file-based resource property, loaded as an external file using the SettingResourceHandler API. In the SolarNode GUI a file setting is rendered as an HTML file input, like this:</p> <p></p> <p>The <code>net.solarnetwork.node.settings.support.BasicFileSettingSpecifier</code> class provides the standard implementation of this API. A standard file setting is created like this:</p> <pre><code>// a single file only, no default content\nnew BasicFileSettingSpecifier(\"document\", null,\nnew LinkedHashSet&lt;&gt;(Arrays.asList(\".txt\", \"text/*\")), false);\n\n// multiple files allowed, no default content\nnew BasicFileSettingSpecifier(\"document-list\", null,\nnew LinkedHashSet&lt;&gt;(Arrays.asList(\".txt\", \"text/*\")), true);\n</code></pre>"},{"location":"developers/settings/specifier/#dynamic-list","title":"Dynamic List","text":"<p>A Dynamic List setting allows the user to manage a list of homogeneous items, adding or subtracting items as desired. The items can be literals like strings, or arbitrary objects that define their own settings. In the SolarNode GUI a dynamic list setting is rendered as a pair of HTML buttons to remove and add items, like this:</p> <p></p> <p>A Dynamic List is often backed by a Java <code>Collection</code> or array in the associated component. In addition a special size-adjusting accessor method is required, named after the setter method with <code>Count</code> appended. SolarNode will use this accessor to request a specific size for the dynamic list.</p> Array-backed dynamic list accessorsList-backed dynamic list accessors <pre><code>private String[] names = new String[0];\n\npublic String[] getNames() {\nreturn names;\n}\n\npublic void setNames(String[] names) {\nthis.names = names;\n}\n\npublic int getNamesCount() {\nString[] l = getNames();\nreturn (l == null ? 0 : l.length);\n}\n\npublic void setNamesCount(int count) {\nsetNames(ArrayUtils.arrayOfLength(\ngetNames(), count, String.class, String::new));\n}\n</code></pre> <pre><code>private List&lt;String&gt; names = new ArrayList&lt;&gt;();\n\npublic List&lt;String&gt; getNames() {\nreturn names;\n}\n\npublic void setNames(List&lt;String&gt; names) {\nthis.names = names;\n}\n\npublic int getNamesCount() {\nList&lt;String&gt; l = getNames();\nreturn (l == null ? 0 : l.size());\n}\n\npublic void setNamesCount(int count) {\nif ( count &lt; 0 ) {\ncount = 0;\n}\nList&lt;String&gt; l = getNames();\nint lCount = (l == null ? 0 : l.size());\nwhile ( lCount &gt; count ) {\nl.remove(l.size() - 1);\nlCount--;\n}\nif ( l == null &amp;&amp; count &gt; 0 ) {\nl = new ArrayList&lt;&gt;();\nsetNames(l);\n}\nwhile ( lCount &lt; count ) {\nl.add(\"\");\nlCount++;\n}\n}\n</code></pre> <p>The <code>SettingUtils.dynamicListSettingSpecifier()</code> method simplifies the creation of a <code>GroupSettingSpecifier</code> that represents a dynamic list (the examples in the following sections demonstrate this).</p>"},{"location":"developers/settings/specifier/#simple-dynamic-list","title":"Simple Dynamic List","text":"<p>A simple Dynamic List is a dynamic list of string or number values.</p> <p></p> <pre><code>private String[] names = new String[0];\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;();\n\n// turn a list of strings into a Group of TextField settings\nGroupSettingSpecifier namesList = SettingUtils.dynamicListSettingSpecifier(\n\"names\", asList(names), (String value, int index, String key) -&gt;\nsingletonList(new BasicTextFieldSettingSpecifier(key, null)));\nresults.add(namesList);\n\nreturn results;\n}\n</code></pre>"},{"location":"developers/settings/specifier/#complex-dynamic-list","title":"Complex Dynamic List","text":"<p>A complex Dynamic List is a dynamic list of arbitrary object values. The main difference in terms of the necessary settings structure required, compared to a Simple Dynamic List, is that a group-of-groups is used.</p> <p></p> Complex data classDynamic List setting <pre><code>public class Person {\nprivate String firstName;\nprivate String lastName;\n\n// generate list of settings for a Person, nested under some prefix\npublic List&lt;SettingSpecifier&gt; settings(String prefix) {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;(2);\nresults.add(new BasicTextFieldSettingSpecifier(prefix + \"firstName\", null));\nresults.add(new BasicTextFieldSettingSpecifier(prefix + \"lastName\", null));\nreturn results;\n}\n\npublic void setFirstName(String firstName) {\nthis.firstName = firstName;\n}\n\npublic void setLastName(String lastName) {\nthis.lastName = lastName;\n}\n}\n</code></pre> <pre><code>private Person[] people = new Person[0];\n\n@Override\npublic List&lt;SettingSpecifier&gt; getSettingSpecifiers() {\nList&lt;SettingSpecifier&gt; results = new ArrayList&lt;&gt;();\n\n// turn a list of People into a Group of Group settings\nGroupSettingSpecifier peopleList = SettingUtils.dynamicListSettingSpecifier(\n\"people\", asList(people), (Person value, int index, String key) -&gt;\nsingletonList(new BasicGroupSettingSpecifier(\nvalue.settings(key + \".\"))));\nresults.add(peopleList);\n\nreturn results;\n}\n</code></pre>"},{"location":"users/","title":"User Guide","text":"<p>This section of the handbook is geared towards users who will be deploying and managing one or more SolarNode devices.</p> <p>See the Getting Started page to learn how to:</p> <ul> <li>get SolarNode running on a device, like a Raspberry Pi</li> <li>associate your SolarNode with your SolarNetwork account</li> </ul> <p>See the Setup App section to learn how to configure SolarNode.</p>"},{"location":"users/configuration/","title":"Configuration","text":"<p>Some SolarNode components can be configured from properties files. This type of configuration is meant to be changed just once, when a SolarNode is first deployed, to alter some default configuration value.</p> <p>Not to be confused with Settings</p> <p>This type of configuration differs from what the Settings page in the Setup App provides a UI managing. This configuration might be created by system administrators when creating a custom SolarNodeOS image for their needs, while Settings are meant to be managed by end users.</p> <p>Configuration properties files are read from the <code>/etc/solarnode/services</code> directory and named like <code>NAMESPACE.cfg</code> , where <code>NAMESPACE</code> represents a configuration namespace.</p> <p>Configuration location</p> <p>The <code>/etc/solarnode/services</code> location is the default location in SolarNodeOS. It might be another location in other SolarNode deployments.</p>"},{"location":"users/configuration/#example","title":"Example","text":"<p>Imagine a component uses the configuration namespace <code>com.example.service</code> and supports a configurable property named <code>max-threads</code> that accepts an integer value you would like to configure as <code>4</code>. You would create a <code>com.example.service.cfg</code> file like:</p> /etc/solarnode/services/com.example.service.cfg<pre><code>max-threads = 4\n</code></pre>"},{"location":"users/datum/","title":"Datum","text":"<p>In SolarNetwork a datum is the fundamental time-stamped data structure collected by SolarNodes and stored in SolarNet. It is a collection of properties associated with a specific information source at a specific time.</p> <p>Example plain language description of a datum</p> <p>the temperature and humidity collected from my weather station at 1 Jan 2023 11:00 UTC</p> <p>In this example datum description, we have all the comopnents of a datum:</p> Datum component Description node the (implied) node that collected the data properties temperature and humidity source my weather station time 1 Jan 2023 11:00 UTC <p>A datum stream is the collection of datum from a single node for a single source over time.</p> <p>A datum object is modeled as a flexible structure with the following core elements:</p> Element Type Description <code>nodeId</code> number A unique ID assigned to nodes by SolarNetwork. <code>sourceId</code> string A node-unique identifier that defines a single stream of data from a specific source, up to 64 characters long. Certain characters are not allowed, see below. <code>created</code> date A time stamp of when the datum was collected, or the date the datum is associated with. <code>samples</code> datum samples The collected properties. <p>A datum is uniquely identified by the three combined properties (<code>nodeId</code>, <code>sourceId</code>, <code>created</code>).</p>"},{"location":"users/datum/#datum-source-ids","title":"Datum source IDs","text":"<p>Source IDs are user-defined strings used to distinguish between different information sources within a single node. For example, a node might collect data from an energy meter on source ID <code>Meter</code> and a solar inverter on <code>Solar</code>. SolarNetwork does not place any restrictions on source ID values, other than a 64-character limit. However, there is are some conventions used within SolarNetwork that are useful to follow, especially for larger deployment of nodes with many source IDs:</p> <ul> <li>Keep IDs as short as, for example <code>Meter1</code> is better than <code>Schneider ION6200 Meter - Main Building</code>.</li> <li>Use a path-like structure to encode a logical hierarchy, in least specific to most specific    order. For example <code>/S1/B1/M1</code> could imply the first meter in the first building on the first site.</li> <li>The <code>+</code> and <code>#</code> characters should not be used. This is actually a constraint in the MQTT    protocol used in parts of SolarNetwork, where the MQTT topic name includes the source ID. These    characters are MQTT topic filter wildcards, and cannot be used in topic names.</li> <li>Avoid using wildcard special characters.</li> </ul> <p>The path-like structure becomes useful in places where wildcard patterns are used, like security policies or datum queries. It is generally worthwhile spending some time planning on a source ID taxonomy to use when starting a new project with SolarNetwork.</p>"},{"location":"users/datum/#datum-samples","title":"Datum samples","text":"<p>The properties included in a datum object are known as datum samples. The samples are modeled as a collection of named properties, for example the temperature and humidity properties in the earlier example datum could be represented like this:</p> Example representation of datum samples from a weather station source<pre><code>{\n\"temperature\" : 21.5,\n\"humidity\"    : 68\n}\n</code></pre> <p>Another datum samples acquired from a power meter might look like this:</p> Example representation of datum samples from a power meter source<pre><code>{\n\"watts\"     : 2150,\n\"wattHours\" : 6834834349,\n\"mode\"      : \"auto\"\n}\n</code></pre>"},{"location":"users/datum/#datum-property-classifications","title":"Datum property classifications","text":"<p>The datum samples are actually further organized into three classifications:</p> Classification Key Description instantaneous <code>i</code> a single reading, observation, or measurement that does not accumulate over time accumulating <code>a</code> a reading that accumulates over time, like a meter or odometer status <code>s</code> non-numeric data, like staus codes or error messages <p>These classifications help SolarNetwork understand how to aggregate the datum samples over time. When SolarNode uploads a datum to SolarNetwork, the sample will include the classification of each property. The previous example would thus more accurately be represented like this:</p> Example representation of datum samples with classifications<pre><code>{\n\"i\": {\n\"watts\"     : 2150 // (1)!\n},\n\"a\": {\n\"wattHours\" : 6834834349 // (2)!\n},\n\"s\": {\n\"mode\"      : \"auto\" // (3)!\n}\n}\n</code></pre> <ol> <li><code>watts</code> is an instantaneous measurement of power that does not accumulate</li> <li><code>wattHours</code> is an accumulating measurement of the accrual of energy over time</li> <li><code>mode</code> is a status message that is not a number</li> </ol> <p>Note</p> <p>Sometimes these classifications will be hidden from you. For example SolarNetwork hides them when returning datum data from some SolarNetwork API methods. You might come across them in some SolarNode plugins that allow configuring dynamic sample properties to collect, when SolarNode does not implicitly know which classification to use. Some SolarNetwork APIs do return or require fully classified sample objects; the documentation for those services will make that clear.</p>"},{"location":"users/expressions/","title":"Expressions","text":"<p>Many SolarNode components support a general \"expressions\" framework that can be used to calculate values using a scripting language. SolarNode comes with the Spel scripting language by default, so this guide describes that language.</p> <p>A common use case for expressions is to derive datum property values out of the raw property values captured from a device. In the SolarNode Setup App a typical datum data source component might present a configurable list of expression settings like this:</p> <p></p> <p>In this example, each time the data source captures a datum from the device it is communicating with it will add a new <code>watts</code> property by multiplying the captured <code>amps</code> and <code>volts</code> property values. In essence the expression is like this code:</p> <pre><code>watts = amps \u00d7 volts\n</code></pre>"},{"location":"users/expressions/#datum-expressions","title":"Datum Expressions","text":"<p>Many SolarNode expressions are evaluated in the context of a datum, typically one captured from a device SolarNode is collecting data from. In this context, the expression supports accessing datum properties directly as expression variables, and some helpful functions are provided.</p>"},{"location":"users/expressions/#datum-property-variables","title":"Datum property variables","text":"<p>All datum properties with simple names can be referred to directly as variables. Here simple just means a name that is also a legal variable name. The property classifications do not matter in this context: the expression will look for properties in all classifications.</p> <p>For example, given a datum like this:</p> Example datum representation in JSON<pre><code>{\n\"i\": {\n\"watts\"     : 123\n},\n\"a\": {\n\"wattHours\" : 987654321\n},\n\"s\": {\n\"mode\"      : \"auto\"\n}\n}\n</code></pre> <p>The expression can use the variables <code>watts</code>, <code>wattHours</code>, and <code>mode</code>.</p>"},{"location":"users/expressions/#other-variables","title":"Other variables","text":"<p>A datum expression will also provide the following variables:</p> Property Type Description <code>datum</code> <code>Datum</code> A <code>Datum</code> object, in case you need direct access to the functions provided there. <code>meta</code> <code>DatumMetadataOperations</code> Get datum metadata for the current source ID. <code>parameters</code> <code>Map&lt;String,Object&gt;</code> Simple map-based access to all parameters passed to the expression. The available parameters depend on the context of the expression evaluation, but often include things like placeholder values or parameters generated by previously evaluated expressions. These values are also available directly as variables, this is rarely needed but can be helpful for accessing dynamically-calculated property names or properties with names that are not legal variable names. <code>props</code> <code>Map&lt;String,Object&gt;</code> Simple map based access to all properties in <code>datum</code>. As datum properties are also available directly as variables, this is rarely needed but can be helpful for accessing dynamically-calculated property names or properties with names that are not legal variable names. <code>sourceId</code> <code>String</code> The source ID of the current datum."},{"location":"users/expressions/#functions","title":"Functions","text":"<p>Some functions are provided to help with datum-related expressions.</p>"},{"location":"users/expressions/#bit-functions","title":"Bit functions","text":"<p>The following functions help with bitwise integer manipulation operations:</p> Function Arguments Result Description <code>and(n1,n2)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Bitwise and, i.e. <code>(n1 &amp; n2)</code> <code>andNot(n1,n2)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Bitwise and-not, i.e. <code>(n1 &amp; ~n2)</code> <code>narrow(n,s)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Return <code>n</code> as a reduced-size but equivalent number of a minimum power-of-two byte size <code>s</code> <code>narrow8(n)</code> <code>Number</code> <code>Number</code> Return <code>n</code> as a reduced-size but equivalent number narrowed to a minimum of 8-bits <code>narrow16(n)</code> <code>Number</code> <code>Number</code> Return <code>n</code> as a reduced-size but equivalent number narrowed to a minimum of 16-bits <code>narrow32(n)</code> <code>Number</code> <code>Number</code> Return <code>n</code> as a reduced-size but equivalent number narrowed to a minimum of 32-bits <code>narrow64(n)</code> <code>Number</code> <code>Number</code> Return <code>n</code> as a reduced-size but equivalent number narrowed to a minimum of 64-bits <code>not(n)</code> <code>Number</code> <code>Number</code> Bitwise not, i.e. <code>(~n)</code> <code>or(n1,n2)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Bitwise or, i.e. <code>(n1 | n2)</code> <code>shiftLeft(n,c)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Bitwise shift left, i.e. <code>(n &lt;&lt; c)</code> <code>shiftRight(n,c)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Bitwise shift left, i.e. <code>(n &gt;&gt; c)</code> <code>testBit(n,i)</code> <code>Number</code>, <code>Number</code> <code>boolean</code> Test if bit <code>i</code> is set in integer <code>n</code>, i.e. <code>((n &amp; (1 &lt;&lt; i)) != 0)</code> <code>xor(n1,n2)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Bitwise xor, i.e. <code>(n1 ^ n2)</code> <p>Tip</p> <p>All number arguments will be converted to <code>BigInteger</code> values for the bitwise operations, and  <code>BigInteger</code> values are returned.</p>"},{"location":"users/expressions/#datum-stream-functions","title":"Datum stream functions","text":"<p>The following functions deal with datum streams. The <code>latest()</code> and <code>offset()</code> functions give you access to recently-captured datum from any SolarNode source, so you can refer to any datum stream being generated in SolarNode. They return another datum expression root object, which means you have access to all the variables and functions documented on this page with them as well.</p> Function Arguments Result Description <code>hasLatest(source)</code> <code>String</code> <code>boolean</code> Returns <code>true</code> if a datum with source ID <code>source</code> is available via the <code>latest(source)</code> function. <code>hasLatestMatching(pattern)</code> <code>String</code> <code>Collection&lt;DatumExpressionRoot&gt;</code> Returns <code>true</code> if <code>latestMatching(pattern)</code> returns a non-empty collection. <code>hasLatestOtherMatching(pattern)</code> <code>String</code> <code>Collection&lt;DatumExpressionRoot&gt;</code> Returns <code>true</code> if <code>latestOthersMatching(pattern)</code> returns a non-empty collection. <code>hasMeta()</code> <code>boolean</code> Returns <code>true</code> if metadata for the current source ID is available. <code>hasMeta(source)</code> <code>String</code> <code>boolean</code> Returns <code>true</code> if <code>datumMeta(source)</code> would return a non-null value. <code>hasOffset(offset)</code> <code>int</code> <code>boolean</code> Returns <code>true</code> if a datum is available via the <code>offset(offset)</code> function. <code>hasOffset(source,offset)</code> <code>String</code>, <code>int</code> <code>boolean</code> Returns <code>true</code> if a datum with source ID <code>source</code> is available via the <code>offset(source,int)</code> function. <code>latest(source)</code> <code>String</code> <code>DatumExpressionRoot</code> Provides access to the latest available datum matching the given source ID, or <code>null</code> if not available. This is a shortcut for calling <code>offset(source,0)</code>. <code>latestMatching(pattern)</code> <code>String</code> <code>Collection&lt;DatumExpressionRoot&gt;</code> Return a collection of the latest available datum matching a given source ID wildcard pattern. <code>latestOthersMatching(pattern)</code> <code>String</code> <code>Collection&lt;DatumExpressionRoot&gt;</code> Return a collection of the latest available datum matching a given source ID wildcard pattern, excluding the current datum if its source ID happens to match the pattern. <code>meta(source)</code> <code>String</code> <code>DatumMetadataOperations</code> Get datum metadata for a specific source ID. <code>metaMatching(pattern)</code> <code>String</code> <code>Collection&lt;DatumMetadataOperations&gt;</code> Find datum metadata for sources matching a given source ID wildcard pattern. <code>offset(offset)</code> <code>int</code> <code>DatumExpressionRoot</code> Provides access to a datum from the same stream as the current datum, offset by <code>offset</code> in time, or <code>null</code> if not available. Offset <code>1</code> means the datum just before this datum, and so on. <code>offset(source,offset)</code> <code>String</code>, <code>int</code> <code>DatumExpressionRoot</code> Provides access to an offset from the latest available datum matching the given source ID, or <code>null</code> if not available. Offset <code>0</code> represents the \"latest\" datum, <code>1</code> the one before that, and so on. SolarNode only maintains a limited history for each source, do do not rely on more than a few datum to be available via this method. This history is also cleared when SolarNode restarts. <code>selfAndLatestMatching(pattern)</code> <code>String</code> <code>Collection&lt;DatumExpressionRoot&gt;</code> Return a collection of the latest available datum matching a given source ID wildcard pattern, including the current datum.\u00a0The current datum will always be the first datum returned."},{"location":"users/expressions/#math-functions","title":"Math functions","text":"<p>Expressions support basic math operators like <code>+</code> for addition and <code>*</code> for multiplication. The following functions help with other math operations:</p> Function Arguments Result Description <code>avg(collection)</code> <code>Collection&lt;Number&gt;</code> <code>Number</code> Calculate the average (mean) of a collection of numbers. Useful when combined with the <code>group(pattern)</code> function. <code>ceil(n)</code> <code>Number</code> <code>Number</code> Round a number larger, to the nearest integer. <code>ceil(n,significance)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Round a number larger, to the nearest integer multiple of <code>significance</code>. <code>down(n)</code> <code>Number</code> <code>Number</code> Round numbers towards zero, to the nearest integer. <code>down(n,significance)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Round numbers towards zero, to the nearest integer multiple of <code>significance</code>. <code>floor(n)</code> <code>Number</code> <code>Number</code> Round a number smaller, to the nearest integer. <code>floor(n,significance)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Round a number smaller, to the nearest integer multiple of <code>significance</code>. <code>max(collection)</code> <code>Collection&lt;Number&gt;</code> <code>Number</code> Return the largest value from a set of numbers. <code>max(n1,n2)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Return the larger of two numbers. <code>min(collection)</code> <code>Collection&lt;Number&gt;</code> <code>Number</code> Return the smallest value from a set of numbers. <code>min(n1,n2)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Return the smaler of two numbers. <code>mround(n,significance)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Round a number to the nearest integer multiple of <code>significance</code>. <code>round(n)</code> <code>Number</code> <code>Number</code> Round a number to the nearest integer. <code>round(n,digits)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Round a number to the nearest number with <code>digits</code> decimal digits. <code>roundDown(n,digits)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Round a number towards zero to the nearest number with <code>digits</code> decimal digits. <code>roundUp(n,digits)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Round a number away from zero to the nearest number with <code>digits</code> decimal digits. <code>sum(collection)</code> <code>Collection&lt;Number&gt;</code> <code>Number</code> Calculate the sum of a collection of numbers. Useful when combined with the <code>group(pattern)</code> function. <code>up(n)</code> <code>Number</code> <code>Number</code> Round numbers away from zero, to the nearest integer. <code>up(n,significance)</code> <code>Number</code>, <code>Number</code> <code>Number</code> Round numbers away from zero, to the nearest integer multiple of <code>significance</code>."},{"location":"users/expressions/#operational-functions","title":"Operational functions","text":"<p>The following functions deal with general SolarNode operations:</p> Function Arguments Result Description <code>isOpMode(mode)</code> <code>String</code> <code>boolean</code> Returns <code>true</code> if the <code>mode</code> operational mode is active."},{"location":"users/expressions/#property-functions","title":"Property functions","text":"<p>The following functions help with expression properties (variables):</p> Function Arguments Result Description <code>has(name)</code> <code>String</code> <code>boolean</code> Returns <code>true</code> if a property named <code>name</code> is defined. Can be used to prevent expression errors on datum property variables that are missing. <code>group(pattern)</code> <code>String</code> <code>Collection&lt;Number&gt;</code> Creates a collection out of numbered properties whose <code>name</code> matches the given regular expression <code>pattern</code>."},{"location":"users/expressions/#expression-examples","title":"Expression examples","text":"<p>Let's assume a captured datum like this, expressed as JSON:</p> <pre><code>{\n\"i\" : {\n\"amps\"      : 4.2,\n\"volts\"     : 240.0\n},\n\"a\" : {\n\"reading\"   : 38009138\n},\n\"s\" : {\n\"state\"     : \"Ok\"\n}\n}\n</code></pre> <p>Then here are some example Spel expressions and the results they would produce:</p> Expression Result Comment <code>state</code> <code>Ok</code> Returns the <code>state</code> status property directly, which is <code>Ok</code>. <code>datum.s['state']</code> <code>Ok</code> Returns the <code>state</code> status property explicitly. <code>props['state']</code> <code>Ok</code> Same result as <code>datum.s['state']</code> but using the short-cut <code>props</code> accessor. <code>amps * volts</code> <code>1008.0</code> Returns the result of multiplying the <code>amps</code> and <code>volts</code> properties together: <code>4.2 \u00d7 240.0 = 1008.0</code>."},{"location":"users/expressions/#datum-stream-history","title":"Datum stream history","text":"<p>Building on the previous example datum, let's assume an earlier datum for the same source ID had been collected with these properties (the classifications have been omitted for brevity):</p> <pre><code>{\n\"amps\"    : 3.1,\n\"volts\"   : 241.0,\n\"reading\" : 38009130,\n\"state\"   : \"Ok\"\n}\n</code></pre> <p>Then here are some example expressions and the results they would produce given the original datum example:</p> Expression Result Comment <code>hasOffset(1)</code> <code>true</code> Returns <code>true</code> because of the earlier datum that is available. <code>hasOffset(2)</code> <code>false</code> Returns <code>false</code> because only one earlier datum is available. <code>amps - offset(1).amps</code> <code>1.1</code> Computes the difference between the current and previous <code>amps</code> properties, which is <code>4.2 - 3.1 = 1.1</code>."},{"location":"users/expressions/#other-datum-stream-history","title":"Other datum stream history","text":"<p>Other datum stream histories collected by SolarNode can also be accessed via the <code>offset(source,offset)</code> function. Let's assume SolarNode is collecting a datum stream for the source ID <code>solar</code>, and had amassed the following history, in newest-to-oldest order:</p> <pre><code>[\n{\"amps\" : 6.0, \"volts\" : 240.0 },\n{\"amps\" : 5.9, \"volts\" : 239.9 }\n]\n</code></pre> <p>Then here are some example expressions and the results they would produce given the original datum example:</p> Expression Result Comment <code>hasLatest('solar')</code> <code>true</code> Returns <code>true</code> because of a datum for source <code>solar</code> is available. <code>hasOffset('solar',2)</code> <code>false</code> Returns <code>false</code> because only one earlier datum from the latest with source <code>solar</code> is available. <code>(amps * volts) - (latest('solar').amps * latest('solar').volts)</code> <code>432.0</code> Computes the difference in energy between the latest <code>solar</code> datum and the current datum, which is <code>(6.0 \u00d7 240.0) - (4.2 \u00d7 240.0) = 432.0</code>. <p>If we add another datum stream for the source ID <code>solar1</code> like this:</p> <pre><code>[\n{\"amps\" : 1.0, \"volts\" : 240.0 }\n]\n</code></pre> <p>If we also add another datum stream for the source ID <code>solar2</code> like this:</p> <pre><code>[\n{\"amps\" : 3.0, \"volts\" : 240.0 }\n]\n</code></pre> <p>Then here are some example expressions and the results they would produce given the previous datum examples:</p> Expression Result Comment <code>sum(latestMatching('solar*').?[amps&gt;1].![amps * volts])</code> <code>2160</code> Returns the sum power of the latest <code>solar</code> and <code>solar2</code> datum. The <code>solar1</code> power is omitted because its <code>amps</code> property is not greater than <code>1</code>, so we end up with <code>(6 * 240) + (3 * 240) = 2160</code>."},{"location":"users/expressions/#datum-metadata","title":"Datum metadata","text":"<p>Some functions return <code>DatumMetadataOperations</code> objects. These objects provide metadata for things like a specific source ID on SolarNode.</p>"},{"location":"users/expressions/#datum-metadata-properties","title":"Datum metadata properties","text":"<p>The properties available on datum metadata objects are:</p> Property Type Description <code>empty</code> <code>boolean</code> Is <code>true</code> if the metadata does not contain any values. <code>info</code> <code>Map&lt;String,Object&gt;</code> Simple map based access to the general metadata (e.g. the keys of the <code>m</code> metadata map). <code>infoKeys</code> <code>Set&lt;String&gt;</code> The set of general metadata keys available (e.g. the keys of the <code>m</code> metadata map). <code>propertyInfoKeys</code> <code>Set&lt;String&gt;</code> The set of property metadata keys available (e.g. the keys of the <code>pm</code> metadata map). <code>tags</code> <code>Set&lt;String&gt;</code> A set of tags associated with the metadata."},{"location":"users/expressions/#datum-metadata-general-info-functions","title":"Datum metadata general info functions","text":"<p>The following functions available on datum metadata objects support access to the general metadata (e.g. the <code>m</code> metadata map):</p> Function Arguments Result Description <code>getInfo(key)</code> <code>String</code> <code>Object</code> Get the general metadata value for a specific key. <code>getInfoNumber(key)</code> <code>String</code> <code>Number</code> Get a general metadata value for a specific key as a <code>Number</code>. Other more specific number value functions are also available such as <code>getInfoInteger(key)</code> or <code>getInfoBigDecimal(key)</code>. <code>getInfoString(key)</code> <code>String</code> <code>String</code> Get a general metadata value for a specific key as a <code>String</code>. <code>hasInfo(key)</code> <code>String</code> <code>boolean</code> Returns <code>true</code> if a non-null general metadata value exists for the given key."},{"location":"users/expressions/#datum-metadata-property-info-functions","title":"Datum metadata property info functions","text":"<p>The following functions available on datum metadata objects support access to the property metadata (e.g. the <code>pm</code> metadata map):</p> Function Arguments Result Description <code>getPropertyInfo(prop)</code> <code>String</code> <code>Map&lt;String,Object&gt;</code> Get the property metadata for a specific property. <code>getInfoNumber(prop,key)</code> <code>String</code>, <code>String</code> <code>Number</code> Get a property metadata value for a specific property and key as a <code>Number</code>. Other more specific number value functions are also available such as <code>getInfoInteger(prop,key)</code> or <code>getInfoBigDecimal(prop,key)</code>. <code>getInfoString(prop,key)</code> <code>String</code>, <code>String</code> <code>String</code> Get a property metadata value for a specific property and key as a <code>String</code>. <code>hasInfo(prop,key)</code> <code>String</code>, <code>String</code> <code>String</code> Returns <code>true</code> if a non-null property metadata value exists for the given property and key."},{"location":"users/expressions/#datum-metadata-global-functions","title":"Datum metadata global functions","text":"<p>The following functions available on datum metadata objects support access to both general and property metadata:</p> Function Arguments Result Description <code>differsFrom(metadata)</code> <code>DatumMetadataOperations</code> <code>boolean</code> Returns <code>true</code> if the given metadata has any different values than the receiver. <code>hasTag(tag)</code> <code>String</code> <code>boolean</code> Returns <code>true</code> if the given tag is available. <code>metadataAtPath(path)</code> <code>String</code> <code>Object</code> Get the metadata value at a metadata key path. <code>hasMetadataAtPath(path)</code> <code>String</code> <code>boolean</code> Returns <code>true</code> if <code>metadataAtPath(path)</code> would return a non-null value."},{"location":"users/getting-started/","title":"Getting Started","text":"<p>This section describes how to get SolarNode running on a device. You will need to configure your device as a SolarNode and associate your SolarNode with SolarNetwork.</p> <p>Tip</p> <p>You might find it helpful to read through this entire guide before jumping in. There are screen shots and tips provided to help you along the way.</p>"},{"location":"users/getting-started/#get-your-device-ready-to-use","title":"Get your device ready to use","text":"<p>SolarNode can run on a variety of devices. To get started using SolarNode, you must download the appropriate SolarNodeOS image for your device. SolarNodeOS is a complete operating system tailor made for SolarNode.  Choose the SolarNodeOS image for the device you want to run SolarNode on and then copy that image to your device media (typically an SD card).</p>"},{"location":"users/getting-started/#choose-your-device","title":"Choose your device","text":"Raspberry PiOrange PiSomething Else <p>The Raspberry Pi is the best supported option for general SolarNode deployments. Models 3 or later, Compute Module 3 or later, and Zero 2 W or later are supported. Use a tool like Etcher or Raspberry Pi Imager to copy the image to an SD card (minimum size is 2 GB, 4 GB recommended).</p> <p> Download SolarNodeOS for Raspberry Pi</p> <p>The Orange Pi models Zero and Zero Plus are supported. Use a tool like Etcher to copy the image to an SD card (minimum size is 1 GB, 4 GB recommended).</p> <p> Download SolarNodeOS for Orange Pi</p> <p>Looking for SolarNodeOS for a device not listed here? Reach out to us through email or Slack to see if we can help!</p>"},{"location":"users/getting-started/#configure-your-network","title":"Configure your network","text":"<p>SolarNode needs a network connection. If your device has an ethernet port, that is the most reliable way to get started: just plug in your ethernet cable and off you go!</p> <p>If you want to use WiFi, or would like more detailed information about SolarNode's networking options, see the Networking sections.</p>"},{"location":"users/getting-started/#power-it-on","title":"Power it on","text":"<p>Insert your SD card (or other device media) into your device, and power it on. While it starts up, proceed with the next steps.</p>"},{"location":"users/getting-started/#associate-your-solarnode-with-solarnetwork","title":"Associate your SolarNode with SolarNetwork","text":"<p>Every SolarNode must be associated (registered) with a SolarNetwork account. To associate a SolarNode, you must:</p> <ol> <li>Log into SolarNetwork</li> <li>Generate an invitation for a new SolarNode</li> <li>Accept the invitation on SolarNode</li> </ol>"},{"location":"users/getting-started/#log-into-solarnetwork","title":"Log into SolarNetwork","text":"<p>If you do not already have a SolarNetwork account, register for one and then log in.</p>"},{"location":"users/getting-started/#generate-a-solarnode-invitation","title":"Generate a SolarNode invitation","text":"<p>Click on the My Nodes link. You will see an Invite New SolarNode button, like this:</p> <p></p> <p>Click the Invite New SolarNode button, then fill in and submit the form that appears and select your time zone by clicking on the world map:</p> <p></p> <p>The generated SolarNode invitation will appear next.</p> <p></p> <p>Select and copy the entire invitation. You will need to paste that into the SolarNode setup screen in the next section.</p>"},{"location":"users/getting-started/#accept-the-invitation-on-solarnode","title":"Accept the invitation on SolarNode","text":"<p>Open the SolarNode Setup app in your browser. The URL to use might be http://solarnode/ or it might be an IP address like <code>http://192.168.1.123</code>. See the Networking section for more information. You will be greeted with an invitation acceptance form into which you can paste the invitation you generated in SolarNetwork. The acceptance process goes through the following steps:</p> <ol> <li>Submit the invitation in the acceptance form</li> <li>Preview the invitation details</li> <li>Confirm the invitation</li> </ol> Acceptance formPreviewConfirmComplete <p>First you submit the invitation in the acceptance form.</p> <p></p> <p>Next you preview the invitation details.</p> <p>Note</p> <p>The expected SolarNetwork Service value shown in this step will be <code>in.solarnetwork.net</code>.</p> <p></p> <p>Finally, confirm the invitation. This step contacts SolarNetwork and completes the association process.</p> <p>Warning</p> <p>Ensure you provide a Certificate Password on this step, so SolarNetwork can generate a security certificate for your SolarNode.</p> <p></p> <p>When these steps are completed, SolarNetwork will have assigned your SolarNode a unique identifier known as your Node ID. A randomly generated SolarNode login password will have been generated; you are given the opportunity to easily change that if you prefer.</p> <p></p>"},{"location":"users/getting-started/#next-steps","title":"Next steps","text":"<p>Learn more about the SolarNode Setup app.</p>"},{"location":"users/logging/","title":"Logging","text":"<p>Logging in SolarNode is configured in the <code>/etc/solarnode/log4j2.xml</code> file, which is in the log4j configuration format. The default configuration in SolarNodeOS sets the overall verbosity to <code>INFO</code> and logs to a temporary storage area <code>/run/solarnode/log/solarnode.log</code>.</p>"},{"location":"users/logging/#logging-concepts","title":"Logging concepts","text":"<p>Log messages have the following general properties:</p> Component Example Description Timestamp <code>2022-03-15 09:05:37,029</code> The date/time the message was generated. Note the format of the timestamp depends on the logging configuration; the SolarNode default is shown in this example. Level <code>INFO</code> The severity/verbosity of the message (as determined by the developer). This is an enumeration, and from least-to-most severe: <code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>.  The level of a given logger allows messages with that level or higher to be logged, while lower levels are skipped. The default SolarNode configuration sets the overal level to <code>INFO</code>, so <code>TRACE</code> and <code>DEBUG</code> messages are not logged. Logger <code>ModbusDatumDataSource</code> A category or namespace associated with the message. Most commonly these equate to Java class names, but can be any value and is determined by the developer. Periods in the logger name act as a delimiter, forming a hierarchy that can be tuned to log at different levels. For example, given the default <code>INFO</code> level, configuring the <code>net.solarnetwork.node.io.modbus</code> logger to <code>DEBUG</code> would turn on debug-level logging for all loggers in the Modbus IO namespace. Note that the default SolarNode configuration logs just a fixed number of the last characters of the logger name. This can be changed in the configuration to log more (or all) of the name, as desired. Message <code>Error reading from device.</code> The message itself, determined by the developer. Exception Some messages include an exception stack trace, which shows the runtime call tree where the exception occurred."},{"location":"users/logging/#logger-namespaces","title":"Logger namespaces","text":"<p>The Logger component outlined in the previous section allows a lot of flexibility to configure what gets logged in SolarNode. Setting the level on a given namespace impacts that namespace as well as all namespaces beneath it, meaning all other loggers that share the same namespace prefix.</p> <p>For example, imagine the following two loggers exist in SolarNode:</p> <ul> <li><code>net.solarnetwork.node.io.modbus.serial.SerialModbusNetwork</code></li> <li><code>net.solarnetwork.node.io.modbus.util.ModbusUtils</code></li> </ul> <p>Given the default configuration sets the default level to <code>INFO</code>, we can turn in <code>DEBUG</code> logging for both of these by adding a <code>&lt;Logger&gt;</code> line like the following within the <code>&lt;Loggers&gt;</code> element:</p> <pre><code>&lt;Logger name=\"net.solarnetwork.node.io.modbus\" level=\"debug\"/&gt;\n</code></pre> <p>That turns on <code>DEBUG</code> for both loggers because they are both children of the <code>net.solarnetwork.node.io.modbus</code> namespace. We could turn on <code>TRACE</code> logging for one of them like this:</p> <pre><code>&lt;Logger name=\"net.solarnetwork.node.io.modbus\"        level=\"debug\"/&gt;\n&lt;Logger name=\"net.solarnetwork.node.io.modbus.serial\" level=\"trace\"/&gt;\n</code></pre> <p>That would also turn on <code>TRACE</code> for any other loggers in the <code>net.solarnetwork.node.io.modbus.serial</code> namespace. You can limit the configuration all the way down to a full logger name if you like, for example:</p> <pre><code>&lt;Logger name=\"net.solarnetwork.node.io.modbus\"                            level=\"debug\"/&gt;\n&lt;Logger name=\"net.solarnetwork.node.io.modbus.serial.SerialModbusNetwork\" level=\"trace\"/&gt;\n</code></pre>"},{"location":"users/logging/#logging-ui","title":"Logging UI","text":"<p>The SolarNode UI supports configuring logger levels dynamically, without having to change the logging configuration file. See the Setup App / Settings / Logging page for more information.</p>"},{"location":"users/logging/#storage-constraints","title":"Storage constraints","text":"<p>The default SolarNode configuration automatically rotates log files based on size, and limits the number of historic log files kept around, to that its associated storage space is not filled up. When a log file reaches the file limit, it is renamed to include a <code>-i.log</code> suffix, where <code>i</code> is an offset from the current log. The default configuration sets the maximum log size to 1 MB and limits the number of historic files to 3.</p> <p>You can also adjust how much history is saved by tweaking the <code>&lt;SizeBasedTriggeringPolicy&gt;</code> and <code>&lt;DefaultRolloverStrategy&gt;</code> configuration. For example to change to a limit of 9 historic files of at most 5 MB each, the configuration would look like this:</p> <pre><code>&lt;Policies&gt;\n&lt;SizeBasedTriggeringPolicy size=\"5 MB\"/&gt;\n&lt;/Policies&gt;\n&lt;DefaultRolloverStrategy max=\"9\"/&gt;\n</code></pre>"},{"location":"users/logging/#persistent-logging","title":"Persistent logging","text":"<p>By default SolarNode logs to temporary (RAM) storage that is discarded when the node reboots. The configuration can be changed so that logs are written directly to persistent storage if you would like to have the logs persisted across reboots, or would like to preserve more log history than can be stored in the temporary storage area.</p> <p>To make this change, update the <code>&lt;RollingFile&gt;</code> element's <code>fileName</code> and/or <code>filePattern</code> attributes to point to a persistent filesystem. SolarNode already has write permission to the <code>/var/lib/solarnode/var</code> directory, so an easy location to use is <code>/var/lib/solarnode/var/log</code>, like this:</p> <pre><code>&lt;RollingFile name=\"File\"\nimmediateFlush=\"false\"\nfileName=\"/var/lib/solarnode/var/log/solarnode.log\"\nfilePattern=\"/var/lib/solarnode/var/log/solarnode-%i.log\"&gt;\n</code></pre> <p>Warning</p> <p>This configuration can add a lot of stress to the node's storage medium, and may shorten its useful life. Consumer-grade SD cards in particular can fail quickly if SolarNode is writting a lot of information, such as verbose logging. Use of this configuration should be used with caution.</p>"},{"location":"users/logging/#logging-example-split-across-multiple-files","title":"Logging example: split across multiple files","text":"<p>Sometimes it can be useful to turn on verbose logging for some area of SolarNode, but have those messages go to a different file so they don't clog up the main <code>solarnode.log</code> file. This can be done by configuring additional appender configurations.</p> <p>The following example logging configuration creates the following log files:</p> <ul> <li><code>/var/log/solarnode/solarnode.log</code> - the main log</li> <li><code>/var/log/solarnode/filter.log</code> - filter logging</li> <li><code>/var/log/solarnode/mqtt-solarin.log</code> - MQTT wire logging to SolarIn</li> <li><code>/var/log/solarnode/mqtt-solarflux.log</code> - MQTT wire logging to SolarFlux</li> </ul> <p>First you must create the <code>/var/log/solarnode</code> directory and give SolarNode permission to write there:</p> <pre><code>sudo mkdir /var/log/solarnode\nsudo chgrp solar /var/log/solarnode\nsudo chmod g+w /var/log/solarnode\n</code></pre> <p>Then edit the <code>/etc/solarnode/log4j2.xml</code> file to hold the following (adjust according to your needs):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Configuration status=\"WARN\"&gt;\n&lt;Appenders&gt;\n&lt;RollingFile name=\"File\"\nimmediateFlush=\"true\"\nfileName=\"/var/log/solarnode/solarnode.log\"\nfilePattern=\"/var/log/solarnode/solarnode-%i.log\"&gt;&lt;!-- (1)! --&gt;\n&lt;PatternLayout pattern=\"%d{DEFAULT} %-5p %40.40c; %msg%n\"/&gt;\n&lt;Policies&gt;\n&lt;SizeBasedTriggeringPolicy size=\"5 MB\"/&gt;\n&lt;/Policies&gt;\n&lt;DefaultRolloverStrategy max=\"9\"/&gt;\n&lt;/RollingFile&gt;\n&lt;RollingFile name=\"Filter\"\nimmediateFlush=\"false\"\nfileName=\"/var/log/solarnode/filter.log\"\nfilePattern=\"/var/log/solarnode/filter-%i.log\"&gt;&lt;!-- (2)! --&gt;\n&lt;PatternLayout pattern=\"%d{DEFAULT} %-5p %40.40c; %msg%n\"/&gt;\n&lt;Policies&gt;\n&lt;SizeBasedTriggeringPolicy size=\"10 MB\"/&gt;\n&lt;/Policies&gt;\n&lt;DefaultRolloverStrategy max=\"9\"/&gt;\n&lt;/RollingFile&gt;\n&lt;RollingFile name=\"MQTT\"\nimmediateFlush=\"false\"\nfileName=\"/var/log/solarnode/mqtt.log\"\nfilePattern=\"/var/log/solarnode/mqtt-%i.log\"&gt;&lt;!-- (3)! --&gt;\n&lt;PatternLayout pattern=\"%d{DEFAULT} %-5p %40.40c; %msg%n\"/&gt;\n&lt;Policies&gt;\n&lt;SizeBasedTriggeringPolicy size=\"10 MB\"/&gt;\n&lt;/Policies&gt;\n&lt;DefaultRolloverStrategy max=\"9\"/&gt;\n&lt;/RollingFile&gt;\n&lt;RollingFile name=\"Flux\"\nimmediateFlush=\"false\"\nfileName=\"/var/log/solarnode/flux.log\"\nfilePattern=\"/var/log/solarnode/flux-%i.log\"&gt;&lt;!-- (4)! --&gt;\n&lt;PatternLayout pattern=\"%d{DEFAULT} %-5p %40.40c; %msg%n\"/&gt;\n&lt;Policies&gt;\n&lt;SizeBasedTriggeringPolicy size=\"10 MB\"/&gt;\n&lt;/Policies&gt;\n&lt;DefaultRolloverStrategy max=\"9\"/&gt;\n&lt;/RollingFile&gt;\n&lt;/Appenders&gt;\n&lt;Loggers&gt;\n&lt;Logger name=\"org.eclipse.gemini.blueprint.blueprint.container.support\" level=\"warn\"/&gt;\n&lt;Logger name=\"org.eclipse.gemini.blueprint.context.support\" level=\"warn\"/&gt;\n&lt;Logger name=\"org.eclipse.gemini.blueprint.service.importer.support\" level=\"warn\"/&gt;\n&lt;Logger name=\"org.springframework.beans.factory\" level=\"warn\"/&gt;\n\n&lt;Logger name=\"net.solarnetwork.node.datum.filter\" level=\"trace\" additivity=\"false\"&gt;\n&lt;AppenderRef ref=\"Filter\"/&gt;&lt;!-- (5)! --&gt;\n&lt;/Logger&gt;\n\n&lt;Logger name=\"net.solarnetwork.mqtt.queue\" level=\"trace\" additivity=\"false\"&gt;\n&lt;AppenderRef ref=\"MQTT\"/&gt;\n&lt;/Logger&gt;\n\n&lt;Logger name=\"net.solarnetwork.mqtt.influx\" level=\"trace\" additivity=\"false\"&gt;\n&lt;AppenderRef ref=\"Flux\"/&gt;\n&lt;/Logger&gt;\n\n&lt;Root level=\"info\"&gt;\n&lt;AppenderRef ref=\"File\"/&gt;&lt;!-- (6)! --&gt;\n&lt;/Root&gt;\n&lt;/Loggers&gt;\n&lt;/Configuration&gt;\n</code></pre> <ol> <li>The <code>File</code> appender is the \"main\" application log where most logs should go.</li> <li>The <code>Filter</code> appender is where we want <code>net.solarnetwork.node.datum.filter</code> messages to go.</li> <li>The <code>MQTT</code> appender is where we want <code>net.solarnetwork.mqtt.queue</code> messages to go.</li> <li>The <code>Flux</code> appender is where we want <code>net.solarnetwork.mqtt.influx</code> messages to go.</li> <li>Here we include <code>additivity=\"false\"</code> and add the <code>&lt;AppenderRef&gt;</code> element that refereneces    the specific appender name we want the log messages to go to. The <code>additivity=false</code> attribute    means the log messages will only go to the <code>Filter</code> appender, instead of also going to    the root-level <code>File</code> appender.</li> <li>The root-level appender is the \"default\" destination for log messages, unless overridden    by a specific appender like we did for the <code>Filter</code>, <code>MQTT</code>, and <code>Flux</code> appenders above.</li> </ol>"},{"location":"users/logging/#separate-file-configuration-notes","title":"Separate file configuration notes","text":"<p>The various <code>&lt;AppenderRef&gt;</code> elements configure the appender name to write the messages to.</p> <p>The various <code>additivity=\"false\"</code> attributes disable appender additivity which means the log message will only be written to one appender, instead of being written to all configured appenders in the hierarchy (for example the root-level appender).</p> <p>The <code>immediateFlush=\"false\"</code> turns on buffered logging, which means log messages are buffered in RAM before being flushed to disk. This is more forgiving to the disk, at the expense of a delay before the messages appear.</p>"},{"location":"users/logging/#enable-mqtt-wire-logging","title":"Enable MQTT wire logging","text":"<p>MQTT wire logging means the raw MQTT packets send and received over MQTT connections will be logged in an easy-to-read but very verbose format. For the MQTT wire logging to be enabled, it must be activated with a special configuration file. Create the <code>/etc/solarnode/services/net.solarnetwork.common.mqtt.netty.cfg</code> file with this content:</p> <pre><code>wireLogging = true\n</code></pre>"},{"location":"users/logging/#mqtt-wire-log-namespace","title":"MQTT wire log namespace","text":"<p>MQTT wire logs use a namespace prefix <code>net.solarnetwork.mqtt.</code> followed by the connection's host name or IP address and port. For example SolarIn messages would use <code>net.solarnetwork.mqtt.queue.solarnetwork.net:8883</code> and SolarFlux messages would use <code>net.solarnetwork.mqtt.influx.solarnetwork.net:8884</code>.</p>"},{"location":"users/networking/","title":"Networking","text":"<p>SolarNode will attempt to automatically configure networking access from a local DHCP server. For many deployments the local network router is the DHCP server. SolarNode will identify itself with the name <code>solarnode</code>, so in many cases you can reach the SolarNode setup app at http://solarnode/.</p>"},{"location":"users/networking/#finding-solarnodes-network-address","title":"Finding SolarNode's network address","text":"<p>To find what network address SolarNode is using, you have a few options:</p>"},{"location":"users/networking/#consult-your-network-router","title":"Consult your network router","text":"<p>Your local network router is very likely to have a record of SolarNode's network connection. Log into the router's management UI and look for a device named <code>solarnode</code>.</p>"},{"location":"users/networking/#connect-a-keyboard-and-screen","title":"Connect a keyboard and screen","text":"<p>If your SolarNode supports connecting a keyboard and screen, you can log into the SolarNode command line console and run <code>ip -br addr</code> to print out a brief summary of the current networking configuration:</p> <pre><code>$ ip -br addr\n\nlo               UNKNOWN        127.0.0.1/8 ::1/128\neth0             UP             192.168.0.254/24 fe80::e65f:1ff:fed1:893c/64\nwlan0            DOWN\n</code></pre> <p>In the previous output, SolarNode has an ethernet device <code>eth0</code> with a network address <code>192.168.0.254</code> and a WiFi device <code>wlan0</code> that is not connected. You could reach that SolarNode at <code>http://192.168.0.254/</code>.</p> <p>Tip</p> <p>You can get more details by running <code>ip addr</code> (without the <code>-br</code> argument).</p>"},{"location":"users/networking/#wifi","title":"WiFi","text":"<p>If your device will use WiFi for network access, you will need to configure the network name and credentials to use. You can do that by creating a <code>wpa_supplicant.conf</code> file on the SolarNodeOS media (typically an SD card). For Raspberry Pi media, you can mount the SD card on your computer and it will mount the appropriate drive for you.</p> <p></p> <p>Once mounted use your favorite text editor to create a <code>wpa_supplicant.conf</code> file with content like this:</p> <pre><code>country=nz\nnetwork={\n    ssid=\"wifi network name here\"\n    psk=\"wifi password here\"\n}\n</code></pre> <p>Change the <code>country=nz</code> to match your own country code.</p>"},{"location":"users/op-modes/","title":"Operational Modes","text":"<p>SolarNode supports a concept called operational modes. Modes are simple names like <code>quiet</code> and <code>hyper</code> that can be either active or inactive. Any number of modes can be active at a given time. In theory both <code>quiet</code> and <code>hyper</code> could be active simultaneously. Modes can be named anything you like.</p> <p>Modes can be used by SolarNode components to alter their behavior dynamically. For example a data source component might stop collecting data from a set of data sources if the <code>quiet</code> mode is active, or start collecting data at an increased frequency if <code>hyper</code> is active. Some components might require specific names, which are described in their documentation. Components that allow configuring a required operational mode setting can also invert the requirement by adding a <code>!</code> prefix to the mode name, for example <code>!hyper</code> can be thought of as \"when <code>hyper</code> is not active\". You can also specify exactly <code>!</code> to match only when no mode is active.</p> <p>Datum Filters also make use of operational modes, to toggle filters on and off dynamically.</p>"},{"location":"users/op-modes/#automatic-expiration","title":"Automatic expiration","text":"<p>Operational modes can be activated with an associated expiration date. The mode will remain active until the expiration date, at which time it will be automatically deactivated. A mode can always be manually deactivated before its associated expiration date.</p>"},{"location":"users/op-modes/#operational-modes-management-api","title":"Operational Modes management API","text":"<p>The SolarUser Instruction API can be used to toggle operational modes on and off. The <code>EnableOperationalModes</code> instruction activates modes and <code>DisableOperationalModes</code> deactivates them.</p>"},{"location":"users/placeholders/","title":"Placeholders","text":"<p>SolarNode supports placeholders in some setting values, such as datum data source IDs. These allow you to define a set of parameters that can be consistently applied to many settings.</p> <p>For example, imagine you manage many SolarNode devices across different buildings or sites. You'd like to follow a naming convention for your datum data source ID values that include a code for the building the node is deployed in, along the lines of <code>/BUILDING/DEVICE</code>. You could define a placeholder <code>building</code> and then configure the source IDs like <code>/{building}/device</code>. On each node you'd define the <code>building</code> placeholder with a building-specific value, so at runtime the nodes would resolve actual source ID values with those names replacing the <code>{building}</code> placeholder, for example <code>/OFFICE1/meter</code>.</p>"},{"location":"users/placeholders/#placeholder-syntax","title":"Placeholder syntax","text":"<p>Placeholders are written using the form <code>{name:default}</code> where <code>name</code> is the placeholder name and <code>default</code> is an optional default value to apply if no placeholder value exists for the given name. If a default value is not needed, omit the <code>colon</code> so the placeholder becomes just <code>{name}</code>.</p> <p>For example, imagine a set of placeholder values like</p> Name Value building OFFICE1 room BREAK <p>Here are some example settings with placeholders with what they would resolve to:</p> Input Resolved value <code>/{building}/meter</code> <code>/OFFICE1/meter</code> <code>/{building}/{room}/temp</code> <code>/OFFICE1/BREAK/temp</code> <code>/{building}/{floor:1}/{room}</code> <code>/OFFICE1/1/BREAK</code>"},{"location":"users/placeholders/#static-placeholder-configuration","title":"Static placeholder configuration","text":"<p>SolarNode will look for placeholder values defined in properties files stored in the <code>conf/placeholders.d</code> directory by default. In SolarNodeOS this is the <code>/etc/solarnode/placeholders.d</code> directory.</p> <p>Warning</p> <p>These files are only loaded once, when SolarNode starts up. If you make changes to any of them then SolarNode must be restarted.</p> <p>The properties file names must have a <code>.properties</code> extension and follow Java properties file syntax. Put simply, each file contains lines like</p> <pre><code>name = value\n</code></pre> <p>where <code>name</code> is the placeholder name and <code>value</code> is its associated value. The example set of placeholder values shown previously could be defined in a <code>/etc/solarnode/placeholders.d/mynode.properties</code> file with this content:</p> <pre><code>building = OFFICE1\nroom = BREAK\n</code></pre>"},{"location":"users/placeholders/#dynamic-placeholder-configuration","title":"Dynamic placeholder configuration","text":"<p>SolarNode also supports storing placeholder values as Settings using the key <code>placeholder</code>. The SolarUser /instruction/add API can be used with the UpdateSetting topic to modify the placeholder values as needed. The <code>type</code> value is the placeholder name and the <code>value</code> the placeholder value. Placeholders defined this way have priority over any similarly-named placeholders defined statically. Changes take effect as soon as SolarNode receives and processes the instruction.</p> <p>Warning</p> <p>Once a placeholder value is set via the <code>UpdateSetting</code> instruction, the same value defined as a static placeholder will be overridden and changes to the static value will be ignored.</p> <p>For example, to set the <code>floor</code> placeholder to <code>2</code> on node 123, you could make a <code>POST</code> request to <code>/solaruser/api/v1/sec/instr/add/UpdateSetting</code> with the following JSON body:</p> <pre><code>{\n\"nodeId\": 123,\n\"params\":{\n\"key\":   \"placeholder\",\n\"type\":  \"floor\",\n\"value\": \"2\"\n}\n}\n</code></pre> <p>Multiple settings can be updated as well, using a different syntax. Here's a request that sets both <code>floor</code> to <code>2</code> and <code>room</code> to <code>MEET</code>:</p> <pre><code>{\"nodeId\":123,\"parameters\":[\n{\"name\":\"key\",   \"value\":\"placeholder\"},\n{\"name\":\"type\",  \"value\":\"floor\"},\n{\"name\":\"value\", \"value\":\"2\"},\n{\"name\":\"key\",   \"value\":\"placeholder\"},\n{\"name\":\"type\",  \"value\":\"room\"},\n{\"name\":\"value\", \"value\":\"MEET\"}\n]}\n</code></pre>"},{"location":"users/remote-access/","title":"Remote Access","text":"<p>SolarSSH is SolarNetwork's method of connecting to SolarNode devices over the internet even when those devices are not directly reachable due to network firewalls or routing rules. It uses the Secure Shell Protocol (SSH) to ensure your connection is private and secure.</p> <p>SolarSSH does not maintain permanently open SSH connections to SolarNode devices. Instead the connections are established on demand, when you need them. This allows you to connect to a SolarNode when you need to perform maintenance, but not require SolarNode maintain an open SSH connection to SolarSSH.</p> <p>In order to use SolarSSH, you will need a User Security Token to use for authentication.</p>"},{"location":"users/remote-access/#browser-connection","title":"Browser Connection","text":"<p>You can use SolarSSH right in your browser to connect to any of your nodes.</p> <p> </p> <p>The SolarSSH browser app</p>"},{"location":"users/remote-access/#choose-your-node-id","title":"Choose your node ID","text":"<p>Click on the node ID in the page title to change what node you want to connect to.</p> <p> </p> <p>Changing the SolarSSH node ID</p> <p>Bookmark a SolarSSH page for your node ID</p> <p>You can append a <code>?nodeId=X</code> to the SolarSSH browser URL https://go.solarnetwork.net/solarssh/, where <code>X</code> is a node ID, to make the app start with that node ID directly. For example to start with node 123, you could bookmark the URL https://go.solarnetwork.net/solarssh/?nodeId=123.</p>"},{"location":"users/remote-access/#provide-your-credentials","title":"Provide your credentials","text":"<p>Fill in User Security Token credentials for authentication. The node ID you are connecting to must be owned by the same account as the security token.</p>"},{"location":"users/remote-access/#connect","title":"Connect","text":"<p>Click the Connect button to initiate the SolarSSH connection process. You will be presented with a dialog form to provide your SolarNodeOS system account credentials. This is only necessary if you want to connect to the SolarNodeOS system command line. If you only need to access the SolarNode Setup App, you can click the Skip button to skip this step. Otherwise, click the Login button to log into the system command line.</p> <p> </p> <p>SolarNodeOS system account credentials form</p> <p>SolarSSH will then establish the connection to your node. If you provided SolarNodeOS system account credentials previously and clicked the Login button, you will end up with a system command prompt, like this:</p> <p> </p> <p>SolarSSH logged-in system command prompt</p>"},{"location":"users/remote-access/#remote-setup-app","title":"Remote Setup App","text":"<p>Once connected, you can access the remote node's Setup App by clicking the Setup button in the top-right corner of the window. This will open a new browser tab for the Setup App.</p> <p> </p> <p>Accessing the SolarNode Setup App through a SolarSSH web connection</p>"},{"location":"users/remote-access/#direct-connection","title":"Direct connection","text":"<p>SolarSSH also supports a \"direct\" connection mode, that allows you to connect using standard ssh client applications. This is a more advanced (and flexible) way of connecting to your nodes, and even allows you to access other network services on the same network as the node and provides full SSH integration including port forwarding, <code>scp</code>, and <code>sftp</code> support.</p> <p>Direct SolarSSH connections require using a SSH client that supports the SSH \"jump\" host feature. The \"jump\" server hosted by SolarNetwork Foundation is available at <code>ssh.solarnetwork.net:9022</code>.</p> <p>The \"jump\" connection user is formed by combining a node ID with a user security token, separated by a <code>:</code> character. The general form of a SolarSSH direct connection \"jump\" host thus looks like this:</p> <pre><code>NODE:TOKEN@ssh.solarnetwork.net:9022\n</code></pre> <p>where <code>NODE</code> is a SolarNode ID and <code>TOKEN</code> is a SolarNetwork user security token.</p> <p>The actual SolarNode user can be any OS user (typically <code>solar</code>) and the hostname can be anything. A good practice for the hostname is to use one derived from the SolarNode ID, e.g. <code>solarnode-123</code>.</p> <p>Using OpenSSH a complete connection command to log in as a <code>solar</code> user looks like this, passing the \"jump\" host via a <code>-J</code> argument:</p> <pre><code>ssh -J 'NODE:TOKEN@ssh.solarnetwork.net:9022' solar@solarnode-NODE\n</code></pre> <p>Warning</p> <p>SolarNetwork security tokens often contain characters that must be escaped with a <code>\\</code> character for your shell to interpret them correctly. For example, a token like <code>9gPa9S;Ux1X3kK)YN6&amp;g</code> might need to have the <code>;)&amp;</code> characters escaped like <code>9gPa9S\\;Ux1X3kK\\)YN6\\&amp;g</code>.</p> <p>You will be first prompted to enter a password, which must be the token secret. You might then be prompted for the SolarNode OS user's password. Here's an example screen shot:</p> <p> </p> <p>Accessing the SolarNode system command line through a SolarSSH direct connection</p>"},{"location":"users/remote-access/#shell-shortcut-function","title":"Shell shortcut function","text":"<p>If you find yourself using SolarSSH connections frequently, a handy <code>bash</code> or <code>zsh</code> shell function can help make the connection process easier to remember. Here's an example that give you a <code>solarssh</code> command that accepts a SolarNode ID argument, followed by any optional SSH arguments:</p> <pre><code>function solarssh () {\nlocal node_id=\"$1\"\nif [ -z \"$node_id\" ]; then\necho 'Must provide node ID , e.g. 123'\nelse\nshift\necho \"Enter SN token secret when first prompted for password. Enter node $node_id password second.\"\nssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR \\\n-J \"$node_id\"'SN_TOKEN_HERE@ssh.solarnetwork.net:9022' $@ solar@solarnode-$node_id\nfi\n}\n</code></pre> <p>Just replace <code>SN_TOKEN_HERE</code> with a user security token. After integrating this into your shell's configuration (e.g. <code>~/.bashrc</code> or <code>~/.zshrc</code>) then you could connect to node <code>123</code> like:</p> <pre><code>solarssh 123\n</code></pre>"},{"location":"users/remote-access/#putty","title":"PuTTY","text":"<p>PuTTY is a popular tool for Windows that supports SolarSSH connections. To connect to a SolarNode using PuTTY, you must:</p> <ol> <li>Configure a SSH connection proxy to <code>ssh.solarnetwork.net:9022</code> using a username like     <code>NODEID:TOKENID</code> and the corresponding token secret as the password.</li> <li>Optionally configure a tunnel to <code>localhost:8080</code> to access the SolarNode Setup App</li> <li>Configure the session to connect to <code>solarnode</code> on port <code>22</code></li> </ol>"},{"location":"users/remote-access/#putty-ssh-proxy-connection-configuration","title":"PuTTY SSH proxy connection configuration","text":"<p>Open the Connection &gt; Proxy configuration category in PuTTY, and configure the following settings:</p> Setting Value Proxy type SSH to proxy and use port forwarding Proxy hostname <code>ssh.solarnetwork.net</code> Port <code>9022</code> Username The desired node ID, followed by a <code>:</code>, followed by a user security token ID, that is: <code>NODEID:TOKENID</code> Password The user security token secret. <p> </p> <p>Confiruing PuTTY connection proxy settings</p>"},{"location":"users/remote-access/#putty-ssh-tunnel-configuration","title":"PuTTY SSH tunnel configuration","text":"<p>To access the SolarNode Setup App, you can configure PuTTY to foward a port on your local machine to <code>localhost:8080</code> on the node. Once the SSH connection is established, you can open a browser to <code>http://localhost:PORT</code> to access the SolarNode Setup App. You can use any available local port, for example if you used port <code>8888</code> then you would open a browser to <code>http://localhost:8888</code> to access the SolarNode Setup App.</p> <p>Open the Connection &gt; SSH &gt; Tunnels configuration category in PuTTY, and configure the following settings:</p> Setting Value Source port A free port on your machine, for example <code>8888</code>. Destination <code>localhost:8080</code> Add You must click the Add button to add this tunnel. You can then add other tunnels as needed. <p> </p> <p>Confiruing PuTTY connection SSH tunnel settings</p>"},{"location":"users/remote-access/#putty-session-configuration","title":"PuTTY session configuration","text":"<p>Finally under the Session configuration category in PuTTY, configure the Host Name and Port to connect to SolarNode. You can also provide a session name and click the Save button to save all the settings you have configured, making it easy to load them in the future.</p> Setting Value Host Name Does not actually matter, but a name like <code>solarnode-NODEID</code> is helpful, where <code>NODEID</code> is the ID of the node you are connecting to. Port <code>22</code> <p> </p> <p>Confiruing PuTTY session settings</p>"},{"location":"users/remote-access/#putty-open-connection","title":"PuTTY open connection","text":"<p>On the Session configuration category, click the Open button to establish the SolarSSH connection. You might be prompted to confirm the identity of the <code>ssh.solarnetwork.net</code> server first. Click the Accept button if this is the case.</p> <p> </p> <p>PuTTY host verification alert</p> <p>PuTTY will connect to SolarSSH and after a short while prompt you for the SolarNodeOS user you would like to connect to SolarNode with. Typically you would use the <code>solar</code> account, so you would type <code>solar</code> followed by Enter. You will then be prompted for that account's password, so type that in and type Enter again. You will then be presented with the SolarNodeOS shell prompt.</p> <p> </p> <p>PuTTY node login</p> <p>Assuming you configured a SSH tunnel on port <code>8888</code> to <code>localhost:8080</code>, you can now open http://localhost:8888 to access the SolarNode Setup App.</p> <p> </p> <p>Once connected to SolarSSH, access the SolarNode Setup App in your browser.</p>"},{"location":"users/security-tokens/","title":"Security Tokens","text":"<p>Some SolarNode features require SolarNetwork Security Tokens to use as authentication credentails for SolarNetwork services. Security Tokens are managed on the Security Tokens page in SolarNetwork.</p> <p> </p> <p>The Security Tokens page in SolarNetwork</p>"},{"location":"users/security-tokens/#user-tokens","title":"User Tokens","text":"<p>User Security Tokens allow access to web services that perform functions directly on your behalf, for example issue an instruction to your SolarNode.</p> <p>Click the \"+\" button in the User Tokens section to generate a new security token. You will be shown a form where you can give a name, description, and policy restrictions for the token.</p> <p> </p> <p>The form for creating a new User Security Token</p> <p>Click the Generate Security Token button to generate the new token. You will then be shown the generated token. You will need to copy and save the token to a safe and secure place.</p> <p> </p> <p>A newly generated security token \u2014 make sure to save the token in a safe place</p>"},{"location":"users/security-tokens/#data-tokens","title":"Data Tokens","text":"<p>Data Security Tokens allow access to web services that query the data collected by your SolarNodes.</p> <p>Click the \"+\" button in the Data Tokens section to generate a new security token. You will be shown a form where you can give a name, description, and policy restrictions for the token.</p> <p> </p> <p>The form for creating a new Data Security Token</p> <p>Click the Generate Security Token button to generate the new token. You will then be shown the generated token. You will need to copy and save the token to a safe and secure place.</p>"},{"location":"users/security-tokens/#security-policy","title":"Security Policy","text":"<p>Security tokens can be configured with a Security Policy that restricts the types of functions or data the token has permission to access.</p> Policy User Node Description API Paths Restrict the token to specific API methods. Expiry Make the token invalid after a specific date. Minimum Aggregation Restrict the data aggregation level allowed. Node IDs Restrict to specific node IDs. Refresh Allowed Make the token invalid after a specific date. Source IDs Restrict to specific datum source IDs. Node Metadata Restrict to specific node metadata. User Metadata Restrict to specific user metadata."},{"location":"users/security-tokens/#api-paths","title":"API Paths","text":"<p>The API Paths policy restricts the token to specific SolarNet API methods, based on their URL path. If this policy is not included then all API methods are allowed.</p>"},{"location":"users/security-tokens/#expiry","title":"Expiry","text":"<p>The Expiry policy makes the token invalid after a specific date. If this policy is not included, the token does not ever expire.</p>"},{"location":"users/security-tokens/#minimum-aggregation","title":"Minimum Aggregation","text":"<p>The Minimum Aggregation policy restricts the token to a minimum data aggregation level. If this policy is not included, or of the minimum level is set to None, data for any aggregation level is allowed.</p>"},{"location":"users/security-tokens/#node-ids","title":"Node IDs","text":"<p>The Node IDspolicy restrict the token to specific node IDs. If this policy is not included, then the token has access to all node IDs in your SolarNetwork account.</p>"},{"location":"users/security-tokens/#node-metadata","title":"Node Metadata","text":"<p>The Node Metadata policy restricts the token to specific portions of node-level metadata. If this policy is not included then all node metadata is allowed.</p>"},{"location":"users/security-tokens/#refresh-allowed","title":"Refresh Allowed","text":"<p>The Refresh Allowed policy grants applications given a signing key rather than the token's private password can refresh the key as long as the token has not expired.</p>"},{"location":"users/security-tokens/#source-ids","title":"Source IDs","text":"<p>The Source IDs policy restrict the token to specific datum source IDs. If this policy is not included, then the token has access to all source IDs in your SolarNetwork account.</p>"},{"location":"users/security-tokens/#user-metadata","title":"User Metadata","text":"<p>The User Metadata policy restricts the token to specific portions of account-level metadata. If this policy is not included then all user metadata is allowed.</p>"},{"location":"users/settings/","title":"Settings Files","text":"<p>SolarNode plugins support configurable properties, called settings. The SolarNode setup app allows you to manage settings through simple web forms.</p> <p>Settings can also be exported and imported in a CSV format, and can be applied when SolarNode starts up with Auto Settings CSV files. Here is an example of a settings form in the SolarNode setup app:</p> <p></p> <p>There are 3 settings represented in that screen shot:</p> <ol> <li>Schedule</li> <li>Destination</li> <li>Temporary Destination</li> </ol> <p>Tip</p> <p>Nearly every form field you can edit in the SolarNode setup app represents a setting for a component in SolarNode.</p> <p>In the SolarNode setup app the settings can be imported and exported from the main Settings screen in the Settings Backup &amp; Restore section:</p> <p></p>"},{"location":"users/settings/#settings-csv-example","title":"Settings CSV example","text":"<p>Here's an example snippet of a settings CSV file:</p> <pre><code>net.solarnetwork.node.io.modbus.1,serialParams.baudRate,19200,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.1,serialParams.parityString,even,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.1,serialParams.portName,/dev/cuaU0,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.FACTORY,1,1,0,2014-03-01 21:00:31\n</code></pre> <p>These settings all belong to a <code>net.solarnetwork.node.io.modbus</code> component. The meaning of the CSV columns is discussed in the following section.</p>"},{"location":"users/settings/#settings-csv-syntax","title":"Settings CSV syntax","text":"<p>Settings files are CSV (comma separated values) files, easily exported from spreadsheet applications like Microsoft Excel or Google Sheets. The CSV must include a header row, which is skipped. All other rows will be processed as settings.</p> <p>The Settings CSV format uses a quite general format and contains the following columns:</p> # Name Description 1 key A unique identifier for the service the setting applies to. 2 type A unique identifier for the setting with the service specified by <code>key</code>, typically using standard property syntax. 3 value The setting value. 4 flags An integer bitmask of flags associated with the setting. See the flags section for more info. 5 modified The date the setting was last modified, in <code>yyyy-MM-dd HH:mm:ss</code> format. <p>To understand the <code>key</code> and <code>type</code> values required for a given component requires consulting the documentation of the plugin that provides that component. You can get a pretty good picture of what the values are by exporting the settings after configuring a component in SolarNode. Typically the <code>key</code> value will mirror a plugin's Java package name, and <code>type</code> follows a JavaScript-like property accessor syntax representing a configurable property on the component.</p>"},{"location":"users/settings/#setting-property-syntax","title":"Setting property syntax","text":"<p>The <code>type</code> setting value usually defines a component property using a JavaScript-like syntax with these rules:</p> Expression Example Description Property <code>name</code> a property named <code>name</code> Nested property <code>name.subname</code> a nested property <code>subname</code> on a parent property <code>name</code> List property <code>name[0]</code> the first element of an indexed list property named <code>name</code> Map property <code>name['key']</code> the <code>key</code> element of the map property <code>name</code> <p>These rules can be combined into complex expressions, for example <code>propIncludes[0].name</code> or <code>delegate.connectionFactory.propertyFilters['UID']</code>.</p>"},{"location":"users/settings/#setting-flags","title":"Setting flags","text":"<p>Each setting has a set of flags that can be associated with it. The following table outlines the bit offset for each flag along with a description:</p> # Name Description 0 Ignore modification date If this flag is set then changes to the associated setting will not trigger a new auto backup. 1 Volatile If this flag is set then changes to the associated setting will not trigger an internal \"setting changed\" event to be broadcast. <p>Note these are bit offsets, so the decimal value to ignore modification date is <code>1</code>, to mark as volatile is <code>2</code>, and for both is <code>3</code>.</p>"},{"location":"users/settings/#component-factories","title":"Component factories","text":"<p>Many plugins provide component factories which allow you to configure any number of instances of that component. Each component instance is assigned a unique identifier when it is created. In the SolarNode setup app, the component instance identifiers appear throughout the UI:</p> <p></p> <p>In the previous example CSV the Modbus I/O plugin allows you to configure any number of Modbus connection components, each with their own specific settings. That is an example of a component factory. The settings CSV will include a special row to indicate that such a factory component should be activated, using a unique identifier, and then all the settings associated with that factory instance will have that unique identifier appended to its <code>key</code> values.</p> <p>Going back to that example CSV, this is the row that activates a Modbus I/O component instance with an identifier of <code>1</code>:</p> <pre><code>net.solarnetwork.node.io.modbus.FACTORY,1,1,0,2014-03-01 21:00:31\n</code></pre> <p>The synax for <code>key</code> column is simply the service identifier followed by <code>.FACTORY</code>. Then the <code>type</code> and <code>value</code> columns are both set the same unique identifier. In this example that identifier is <code>1</code>. For all settings specific to a factory component, the <code>key</code> column will be the service identifier followed by <code>.IDENTIFIER</code> where <code>IDENTIFIER</code> is the unique instance identifier.</p> <p>Here is an example that shows two factory instances configured: <code>Lighting</code> and <code>HVAC</code>. Each have a different <code>serialParams.portName</code> setting value configured:</p> <pre><code>net.solarnetwork.node.io.modbus.Lighting,serialParams.portName,/dev/cuaU0,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.HVAC,serialParams.portName,/dev/ttyUSB0,0,2014-03-01 21:01:31\nnet.solarnetwork.node.io.modbus.FACTORY,Lighting,Lighting,0,2014-03-01 21:00:31\nnet.solarnetwork.node.io.modbus.FACTORY,HVAC,HVAC,0,2014-03-01 21:00:31\n</code></pre>"},{"location":"users/settings/#auto-settings","title":"Auto settings","text":"<p>SolarNode settings can also be configured through Auto Settings, applied when SolarNode starts up, by placing Settings CSV files in the <code>/etc/solarnode/auto-settings.d</code> directory. These settings are applied only if they don't already exist or the modified date in the settings file is newer than the date they were previously applied.</p>"},{"location":"users/solarflux/","title":"SolarFlux","text":"<p>SolarFlux is the name of a real-time cloud-based service for datum using a publish/subscribe integration model. SolarNode supports publishing datum to SolarFlux and your own applications can subscribe to receive datum messages as they are published.</p> <p>SolarFlux is based on MQTT. To integrate with SolarFlux you use a MQTT client application or library. See the SolarFlux Integration Guide for more information.</p>"},{"location":"users/solarflux/#solarflux-upload-service","title":"SolarFlux Upload Service","text":"<p>SolarNode provides the SolarFlux Upload Service plugin that posts datum captured by SolarNode plugins to SolarFlux.</p>"},{"location":"users/solarflux/#mqtt-message-format","title":"MQTT message format","text":"<p>Each datum message is published as a CBOR encoded map by default, to a MQTT topic based on the datum's source ID. This is essentially a JSON object. The map keys are the datum property names. You can configure a Datum Encoder to encode datum into a different format, by configuring a filter. For example, the Protobuf Datum Encoder supports encoding datum into Protobuf messages.</p> <p>Messages are published with the MQTT <code>retained</code> flag set by default, which means the most recently published datum is saved by SolarFlux. When an application subscribes to a topic it will immediately receive any retained message for that topic. In this way, SolarFlux will provide a \"most recent\" snapshot of all datum across all nodes and sources.</p> Example SolarFlux datum message, expressed as JSON<pre><code>{\n\"_DatumType\": \"net.solarnetwork.node.domain.ACEnergyDatum\",\n\"_DatumTypes\": [\n\"net.solarnetwork.node.domain.ACEnergyDatum\",\n\"net.solarnetwork.node.domain.EnergyDatum\",\n\"net.solarnetwork.node.domain.Datum\",\n\"net.solarnetwork.node.domain.GeneralDatum\"\n],\n\"apparentPower\": 2797,\n\"created\": 1545167905344,\n\"current\": 11.800409317016602,\n\"phase\": \"PhaseB\",\n\"phaseVoltage\": 409.89337158203125,\n\"powerFactor\": 1.2999000549316406,\n\"reactivePower\": -1996,\n\"realPower\": 1958,\n\"sourceId\": \"Ph2\",\n\"voltage\": 236.9553680419922,\n\"watts\": 1958\n}\n</code></pre>"},{"location":"users/solarflux/#mqtt-message-topics","title":"MQTT message topics","text":"<p>The MQTT topic each datum is published to is derived from the node ID and datum source ID, according to this pattern:</p> <pre><code>node/N/datum/A/S\n</code></pre> Pattern Element Description <code>N</code> The node ID the datum was captured on <code>A</code> An aggregation key; will be <code>0</code> for the \"raw\" datum captured in SolarNode <code>S</code> The datum source ID; note that any leading <code>/</code> in the source ID is stripped from the topic Example MQTT topics<pre><code>node/1/datum/0/Meter\nnode/2/datum/0/Building1/Room1/Light1\nnode/2/datum/0/Building1/Room1/Light2\n</code></pre>"},{"location":"users/solarflux/#log-datum-stream","title":"Log datum stream","text":"<p>The <code>EventAdmin</code> Appender is supported, and log events are turned into a datum stream and published to SolarFlux. The log timestamps are used as the datum timestamps.</p>"},{"location":"users/solarflux/#log-datum-stream-topic-mapping","title":"Log datum stream topic mapping","text":"<p>The topic assigned to log events is <code>log/</code> with the log name appended. Period characters (<code>.</code>) in the log name are replaced with slash characters (<code>/</code>). For example, a log name <code>net.solarnetwork.node.datum.modbus.ModbusDatumDataSource</code> will be turned into the topic <code>log/net/solarnetwork/node/datum/modbus/ModbusDatumDataSource</code>.</p>"},{"location":"users/solarflux/#log-datum-stream-properties","title":"Log datum stream properties","text":"<p>The datum stream consists of the following properties:</p> Property Class. Type Description <code>level</code> <code>s</code> String The log level name, e.g. <code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, or <code>FATAL</code>. <code>priority</code> <code>i</code> Integer The log level priority (lower values have more priority), e.g. <code>600</code>, <code>500</code>, <code>400</code>, <code>300</code>, <code>200</code>, or <code>100</code>. <code>name</code> <code>s</code> String The log name. <code>msg</code> <code>s</code> String The log message . <code>exMsg</code> <code>s</code> String An exception message, if an exception was included. <code>exSt</code> <code>s</code> String A newline-delimited list of stack trace element values, if an exception was included."},{"location":"users/solarflux/#settings","title":"Settings","text":"<p>The SolarFlux Upload Service ships with default settings that work out-of-the-box without any configuration. There are many settings you can change to better suit your needs, however.</p> <p></p> <p>Each component configuration contains the following overall settings:</p> Setting Description Host The URI for the SolarFlux server to connect to. Normally this is <code>influx.solarnetwork.net:8884</code>. Username The MQTT username to use. Normally this is <code>solarnode</code>. Password The MQTT password to use. Normally this is not needed as the node's certificate it used for authentication. Exclude Properties A regular expression to match property names on all datum sources to exclude from publishing. Required Mode If configured, an operational mode that must be active for any data to be published. Maximum Republish If offline message persistence has been configured, then the maximum number of offline messages to publish in one go. See the offline persistence section for more information. Reliability The MQTT quality of service level to use. Normally the default of At most once is sufficient. Version The MQTT protocol version to use. Startig with version 5 MQTT topic aliases will be used if the server supports it, which can save a significant amount of network bandwidth when long source IDs are in use. Retained Toggle the MQTT retained message flag. When enabled the MQTT server will store the most recently published message on each topic so it is immediately available when clients connect. Wire Logging Toggle verbose logging on/off to support troubleshooting. The messages are logged to the <code>net.solarnetwork.mqtt</code> topic at <code>DEBUG</code> level. Filters Any number of datum filter configurations. <p>For TLS-encrypted connections, SolarNode will make the node's own X.509 certificate available for client authentication.</p>"},{"location":"users/solarflux/#filter-settings","title":"Filter settings","text":"<p>Each component can define any number of filters, which are used to manipulate the datum published to SolarFlux, such as:</p> <ul> <li>restrict the frequency at which individual datum sources are published</li> <li>restrict which properties of datum are posted</li> <li>encode the message into something other than CBOR</li> </ul> <p>The filter settings can be very useful to constrain how much data is sent to SolarFlux, for example on nodes using mobile internet connections where the cost of posting data is high.</p> <p></p> <p>A filter can configure a Datum Encoder to encode the MQTT message with, if you want to use a format other than the default CBOR encoding. This can be combined with a Source ID pattern to encode specific sources with specific encoders. For example when using the Protobuf Datum Encoder a single Protobuf message type is supported per encoder. If you want to encode different datum sources into different Protobuf messages, you would configure one encoder per message type, and then one filter per source ID with the corresponding encoder.</p> <p>Note</p> <p>All filters are applied in the order they are defined, and then the first filter with a Datum Encoder configured that matches the filter's Source ID pattern will be used to encode the datum. If not Datum Encoder is configured the default CBOR encoding will be used.</p> <p>Each filter configuration contains the following settings:</p> Setting Description Source ID A case-insensitive regular expression to match against datum source IDs. If defined, this filter will only be applied to datum with matching source ID values. If not defined this filter will be applied to all datum. For example <code>^solar</code> would match any source ID starting with solar. Datum Filter The Service Name of a Datum Filter component to apply before encoding and posting datum. Required Mode If configured, an operational mode that must be active for this filter to be applied. Datum Encoder The Service Name if a Datum Encoder component to encode datum with. The encoder will be passed a <code>java.util.Map</code> object with all the datum properties. If not configured then CBOR will be used. Limit Seconds The minimum number of seconds to limit datum that match the configured Source ID pattern. If datum are produced faster than this rate, they will be filtered out. Set to <code>0</code> or leave empty for no limit. Property Includes A list of  case-insensitive regular expressions to match against datum property names. If configured, only properties that match one of these expressions will be included in the filtered output. For example <code>^watt</code> would match any property starting with watt. Property Excludes A list of  case-insensitive regular expressions to match against datum property names. If configured, any property that match one of these expressions will be excluded from the filtered output. For example <code>^temp</code> would match any property starting with temp. Exclusions are applied after property inclusions. <p>Warning</p> <p>The datum <code>sourceId</code> and <code>created</code> properties will be affected by the property include/exclude filters! If you define any include filters, you might want to add an include rule for <code>^created$</code>. You might like to have <code>sourceId</code> removed to conserve bandwidth, given that value is part of the MQTT topic the datum is posted on and thus redundant.</p>"},{"location":"users/solarflux/#offline-message-persistence","title":"Offline message persistence","text":"<p>By default if the connection to the SolarFlux server is down for any reason, all messages that would normally be published to the server will be discarded. This is suitable for most applications that rely on SolarFlux to view real-time status updates only, and SolarNode uploads datum to SolarNet for long-term persistence. For applications that rely on SolarFlux for more, it might be desirable to configure SolarNode to locally cache SolarFlux messages when the connection is down, and then publish those cached messages when the connection is restored. This can be accomplished by deploying the MQTT Persistence plugin.</p> <p>When that plugin is available, all messages processed by this service will be saved locally when the MQTT connection is down, and then posted once the MQTT connection comes back up. Note the following points to consider:</p> <ul> <li>The cached messages will be posted with the MQTT retained flag set to <code>false</code>.</li> <li>The cached messages will be posted in an unspecified order.</li> <li>The cached messages may be posted more than once, regardless of the configured Reliabiliy    setting.</li> </ul>"},{"location":"users/user-metadata-service/","title":"User Metadata Service","text":"<p>TODO</p>"},{"location":"users/datum-filters/","title":"Datum Filters","text":"<p>Datum Filters are services that manipulate datum generated by SolarNode plugins before they are uploaded to SolarNet. Datum Filters vary wildly in the functionality they provide; here are some examples of the things they can do:</p> <ul> <li>Throttle the rate at which datum are saved to SolarNet</li> <li>Remove unwanted properties from datum</li> <li>Split a datum so some properties are moved to another datum stream</li> <li>Join the properties of multiple datum streams into a single datum</li> <li>Inject properties from external services</li> <li>Derive new properties from dynamic expressions</li> </ul> <p>Datum Filters do not create datum</p> <p>It is helpful to remember that Datum Filters do not create datum, they only manipulate datum created elsewhere, typically by datum data sources.</p> <p>There are four main places where datum filters can be applied:</p> <ol> <li>On the Datum Queue, immediately after each datum is captured</li> <li>As a Global Datum Filter, just before uploading to SolarNet</li> <li>On the Global Datum Filter Chain, just before uploading to SolarNet</li> <li>As a SolarFlux Datum Filter, just before uploading to SolarFlux</li> </ol>"},{"location":"users/datum-filters/#datum-queue","title":"Datum Queue","text":"<p>All datum generated by SolarNode plugins are added to the Datum Queue for processing. The datum are processed in the order they are added to the queue. Datum Filters are applied to each datum, each filter's result passed to the next available filter until all filters have been applied.</p> <p> Conceptual diagram of the Datum Queue, processing datum along with filters manipulating them</p> <p>At the end of processing, the datum is either</p> <ol> <li>uploaded to SolarNet immediately, or</li> <li>saved locally, to be uploaded at some point in the future</li> </ol> <p>Most of the time datum are uploaded to SolarNet immediately after processing. If the network is down, or SolarNode is configured to only upload datum in batches, then datum are saved locally in SolarNode, and a periodic job will attempt to upload them later on, in batches.</p> <p>See the Setup App Datum Queue section for information on how to configure the Datum Queue.</p> <p>When to configure filters on the Datum Queue, as opposed to other places?</p> <p>The Datum Queue is a great place to configure filters that must be processed at most once per datum, and do not depend on what time the datum is uploaded to SolarNet.</p>"},{"location":"users/datum-filters/#global-datum-filters","title":"Global Datum Filters","text":"<p>Global Datum Filters are applied to datum just before posting to SolarNetwork. Once an instance is created, it is automatically active and will be applied to datum. This differs from User Datum Filters, which must be explicitly added to a service to be used, either dircectly or indirectly with a Datum Filter Chain.</p> <p>Note</p> <p>Some filters support both Global and User based filter configuration, and often you can achieve the same overall result in multiple ways. Global filters are convenient for the subset of filters that support Global configuration, but for complex filtering often it can be easier to configure all filters as User filters, using the Global Datum Filter Chain as needed.</p>"},{"location":"users/datum-filters/#global-datum-filter-chain","title":"Global Datum Filter Chain","text":"<p>The Global Datum Filter Chain provides a way to apply explicit User Datum Filters to datum just before posting to SolarNetwork.</p>"},{"location":"users/datum-filters/#solarflux-datum-filters","title":"SolarFlux Datum Filters","text":"<p>TODO</p>"},{"location":"users/datum-filters/chain/","title":"Filter Chain","text":"<p>The Datum Filter Chain is a User Datum Filter that you configure with a list, or chain, of other User Datum Filters. When the Filter Chain executes, it executes each of the configured Datum Filters, in the order defined.  This filter can be used like any other Datum Filter, allowing multiple filters to be applied in a defined order.</p> <p> A Filter Chain acts like an ordered group of Datum Filters</p> <p>Tip</p> <p>Some services support configuring only a single Datum Filter setting. You can use a Filter Chain to apply multiple filters in those services.</p>"},{"location":"users/datum-filters/chain/#settings","title":"Settings","text":"<p>Each filter configuration contains the following overall settings:</p> Setting Description Available Filters A read-only list of Service Name values of User Datum Filter components that have been configured. You can copy any value from this list and paste it into the Datum Filters list to include that filter in the chain. Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Datum Filters The list of Service Name values of User Datum Filter components to apply to datum."},{"location":"users/datum-filters/control-updater/","title":"Control Updater Datum Filter","text":"<p>The Control Updater Datum Filter provides a way to update controls with the result of an expression, optionally populating the expression result as a datum property.</p> <p>This filter is provided by the Standard Datum Filters plugin.</p>"},{"location":"users/datum-filters/control-updater/#settings","title":"Settings","text":"<p> The screen shot shows a filter that would toggle the <code>/power/switch/1</code> control on/off based on the <code>frequency</code> property in the <code>/power/1</code> datum stream: on when the frequency is 50 or higher, off otherwise.</p> <p>Each filter configuration contains the following overall settings:</p> Setting Description Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Source ID A case-insensitive pattern to match the input source ID(s) to filter. If omitted then datum for all source ID values will be filtered, otherwise only datum with matching source ID values will be filtered. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Control Configurations A list of control expression configurations. <p>Each control configuration contains the following settings:</p> Setting Description Control ID The ID of the control to update with the expression result. Property The optional datum property to store the expression result in. Property Type The datum property type to use. Expression The expression to evaluate. See below for more info. Expression Language The expression language to write Expression in."},{"location":"users/datum-filters/control-updater/#expressions","title":"Expressions","text":"<p>See the Expressions guide for general expressions reference. The root object is a <code>DatumExpressionRoot</code> that lets you treat all datum properties, and filter parameters, as expression variables directly.</p>"},{"location":"users/datum-filters/downsample/","title":"Downsample Datum Filter","text":"<p>The Downsample Datum Filter provides a way to down-sample higher-frequency datum samples into lower-frequency (averaged) datum samples. The filter will collect a configurable number of samples and then generate a down-sampled sample where an average of each collected instantaneous property is included. In addition minimum and maximum values of each averaged property are added.</p> <p>This filter is provided by the Standard Datum Filters plugin.</p>"},{"location":"users/datum-filters/downsample/#settings","title":"Settings","text":"Setting Description Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Source ID A case-insensitive pattern to match the input source ID(s) to filter. If omitted then datum for all source ID values will be filtered, otherwise only datum with matching source ID values will be filtered. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Sample Count The number of samples to average over. Decimal Scale A maximum number of digits after the decimal point to round to. Set to<code>0</code> to round to whole numbers. Property Excludes A list of property names to exclude. Min Property Template A string format to use for computed minimum property values. Use <code>%s</code> as the placeholder for the original property name, e.g. <code>%s_min</code>. Max Property Template A string format to use for computed maximum property values. Use <code>%s</code> as the placeholder for the original property name, e.g. <code>%s_max</code>."},{"location":"users/datum-filters/expression/","title":"Expression Datum Filter","text":"<p>The Expression Datum Filter provides a way to generate new properties by evaluating expressions against existing properties.</p> <p>This filter is provided by the Standard Datum Filters plugin.</p>"},{"location":"users/datum-filters/expression/#settings","title":"Settings","text":"<p>Each filter configuration contains the following overall settings:</p> Setting Description Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Source ID A case-insensitive pattern to match the input source ID(s) to filter. If omitted then datum for all source ID values will be filtered, otherwise only datum with matching source ID values will be filtered. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Expressions A list of expression configurations that are evaluated to derive datum property values from other property values. <p>Use the + and - buttons to add/remove expression configurations.</p>"},{"location":"users/datum-filters/expression/#expression-settings","title":"Expression settings","text":"<p>Each expression configuration contains the following settings:</p> Setting Description Property The datum property to store the expression result in. Property Type The datum property type to use. Expression The expression to evaluate. See below for more info. Expression Language The expression language to write Expression in."},{"location":"users/datum-filters/expression/#expressions","title":"Expressions","text":"<p>See the SolarNode Expressions guide for general expressions reference. The root object is a <code>DatumExpressionRoot</code> that lets you treat all datum properties, and filter parameters, as expression variables directly, along with the following properties:</p> Property Type Description <code>datum</code> <code>Datum</code> A <code>Datum</code> object, populated with data from all property and virtual meter configurations. <code>props</code> <code>Map&lt;String,Object&gt;</code> Simple Map based access to the properties in <code>datum</code>, and transform parameters, to simplify expressions. <p>The following methods are available:</p> Function Arguments Result Description <code>has(name)</code> <code>String</code> <code>boolean</code> Returns <code>true</code> if a property named <code>name</code> is defined. <code>hasLatest(source)</code> <code>String</code> <code>boolean</code> Returns <code>true</code> if a datum with source ID <code>source</code> is available via the <code>latest(source)</code> function. <code>latest(source)</code> <code>String</code> <code>DatumExpressionRoot</code> for the latest available datum matching the given source ID, or <code>null</code> if not available."},{"location":"users/datum-filters/expression/#expression-examples","title":"Expression examples","text":"<p>Assuming a datum sample with properties like the following:</p> Property Value <code>current</code> <code>7.6</code> <code>voltage</code> <code>240.1</code> <code>status</code> <code>Error</code> <p>Then here are some example expressions and the results they would produce:</p> Expression Result Comment <code>voltage * current</code> <code>1824.76</code> Simple multiplication of two properties. <code>props['voltage'] * props['current']</code> <code>1824.76</code> Another way to write the previous expression. Can be useful if the property names contain non-alphanumeric characters, like spaces. <code>has('frequency') ? 1 : null</code> <code>null</code> Uses the <code>?:</code> if/then/else operator to evaluate to <code>null</code> because the <code>frequency</code> property is not available. When an expression evaluates to <code>null</code> then no property will be added to the output samples. <code>current &gt; 7 or voltage &gt; 245 ? 1 : null</code> <code>1</code> Uses comparison and logic operators to evaluate to <code>1</code> because <code>current</code> is greater than <code>7</code>. <code>voltage * currrent * (hasLatest('battery') ? 1.0 - latest('battery')['soc'] : 1)</code> <code>364.952</code> Assuming a <code>battery</code> datum with a <code>soc</code> property value of <code>0.8</code> then the expression resolves to <code>7.6 * 241.0 * (1.0 - 0.8)</code>."},{"location":"users/datum-filters/join/","title":"Join Datum Filter","text":"<p>The Join Datum Filter provides a way to merge the properties of multiple datum streams into a new derived datum stream.</p> <p>This filter is provided by the Standard Datum Filters plugin.</p>"},{"location":"users/datum-filters/join/#settings","title":"Settings","text":"<p>Each filter configuration contains the following overall settings:</p> Setting Description Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Source ID A case-insensitive pattern to match the input source ID(s) to filter. If omitted then datum for all source ID values will be filtered, otherwise only datum with matching source ID values will be filtered. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Output Source ID The source ID of the merged datum stream. Placeholders are allowed. Coalesce Threshold When <code>2</code> or more then wait until datum from this many different source IDs have been encountered before generating an output datum. Once a coalesced datum has been generated the tracking of input sources resets and another datum will only be generated after the threshold is met again. If <code>1</code> or less, then generate output datum for all input datum. Swallow Input If enabled, then filter out input datum after merging. Otherwise leave the input datum as-is. Source Property Mappings A list of source IDs with associated property name templates to rename the properties with. Each template must contain a <code>{p}</code> parameter which will be replaced by the property names merged from datum encountered with the associated source ID. For example <code>{p}_s1</code> would map an input property <code>watts</code> to <code>watts_s1</code>. <p>Use the + and - buttons to add/remove expression configurations.</p>"},{"location":"users/datum-filters/join/#source-property-mappings-settings","title":"Source Property Mappings settings","text":"<p>Each source property mapping configuration contains the following settings:</p> Setting Description Source ID A source ID pattern to apply the associated Mapping to. Any capture groups (parts of the pattern between <code>()</code> groups) are provided to the Mapping template. Mapping A property name template with a <code>{p}</code> parameter for an input property name to be mapped to a merged (output) property name. Pattern capture groups from Source ID are available starting with <code>{1}</code>. For example <code>{p}_s1</code> would map an input property <code>watts</code> to <code>watts_s1</code>. <p>Unmapped properties are copied</p> <p>If a matching source property mapping does not exist for an input datum source ID then the property names of that datum are used as-is.</p>"},{"location":"users/datum-filters/join/#source-mapping-examples","title":"Source mapping examples","text":"<p>The Source ID pattern can define capture groups that will be provided to the Mapping template as numbered parameters, starting with <code>{1}</code>. For example, assuming an input datum property <code>watts</code>, then:</p> Datum Source ID Source ID Pattern Mapping Result <code>/power/main</code> <code>/power/</code> <code>{p}_main</code> <code>watts_main</code> <code>/power/1</code> <code>/power/(\\d+)$</code> <code>{p}_s{1}</code> <code>watts_s1</code> <code>/power/2</code> <code>/power/(\\d+)$</code> <code>{p}_s{1}</code> <code>watts_s2</code> <code>/solar/1</code> <code>/(\\w+)/(\\d+)$</code> <code>{p}_{1}{2}</code> <code>watts_solar1</code> <p>To help visualize property mapping with a more complete example, let's imagine we have some datum streams being collected and the most recent datum from each look like this:</p> /meter/1 /meter/2 /solar/1 <pre>{\n  \"watts\": 3213,\n}</pre> <pre>{\n  \"watts\": -842,\n}</pre> <pre>{\n  \"watts\"  : 4055,\n  \"current\": 16.89583\n}</pre> <p>Here are some examples of how some source mapping expressions could be defined, including how multiple mappings can be used at once:</p> Source ID Patterns Mappings Result <code>/(\\w+)/(\\d+)</code> <code>{1}_{p}{2}</code> <pre>{\n  \"power_watts1\"  : 3213,\n  \"power_watts2\"  : -842,\n  \"solar_watts1\"  : 4055,\n  \"solar_current\" : 16.89583\n}</pre> <ol> <li><code>/power/(\\d+)</code></li> <li><code>/solar/1</code></li> </ol> <ol> <li><code>{p}_{1}</code></li> <li><code>{p}</code></li> </ol> <pre>{\n  \"watts_1\"  : 3213,\n  \"watts_2\"  : -842,\n  \"watts\"    : 4055,\n  \"current\"  : 16.89583\n}</pre>"},{"location":"users/datum-filters/op-mode/","title":"Operational Mode Datum Filter","text":"<p>The Operational Mode Datum Filter provides a way to evaluate expressions to toggle operational modes. When an expression evaluates to <code>true</code> the associated operational mode is activated. When an expression evaluates to <code>false</code> the associated operational mode is deactivated.</p> <p>This filter is provided by the Standard Datum Filters plugin.</p>"},{"location":"users/datum-filters/op-mode/#settings","title":"Settings","text":"<p>Each filter configuration contains the following overall settings:</p> Setting Description Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Source ID A case-insensitive pattern to match the input source ID(s) to filter. If omitted then datum for all source ID values will be filtered, otherwise only datum with matching source ID values will be filtered. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Expressions A list of expression configurations that are evaluated to toggle operational modes. <p>Use the + and - buttons to add/remove expression configurations.</p>"},{"location":"users/datum-filters/op-mode/#expression-settings","title":"Expression settings","text":"<p>Each expression configuration contains the following settings:</p> Setting Description Mode The operational mode to toggle. Expire Seconds If configured and greater than <code>0</code>, the number of seconds after activating the operational mode to automatically deactivate it. If not configured or <code>0</code> then the operational mode will be deactivated when the expression evaluates to <code>false</code>. See below for more information. Property If configured, the datum property to store the expression result in. See below for more information. Property Type The datum property type to use if Property is configured. See below for more information. Expression The expression to evaluate. See below for more info. Expression Language The expression language to write Expression in."},{"location":"users/datum-filters/op-mode/#expire-setting","title":"Expire setting","text":"<p>When configured the expression will never deactivate the operational mode directly. When evaluating the given expression, if it evaluates to <code>true</code> the mode will be activated and configured to deactivate after this many seconds. If the operation mode was already active, the expiration will be extended by this many seconds.</p> <p>This configuration can be thought of like a time out as used on motion-detecting lights: each time motion is detected the light is turned on (if not already on) and a timer set to turn the light off after so many seconds of no motion being detected.</p> <p>Note that the operational modes service might actually deactivate the given mode a short time after the configured expiration.</p>"},{"location":"users/datum-filters/op-mode/#property-setting","title":"Property setting","text":"<p>A property does not have to be populated. If you provide a Property name to populate, the value of the datum property depends on property type configured:</p> Type Description Instantaneous The property value will be <code>1</code> or <code>0</code> based on <code>true</code> and <code>false</code> expression results. Status The property will be the expression result, so <code>true</code> or <code>false</code>. Tag A tag named as the configured property will be added if the expression is <code>true</code>, or removed if <code>false</code>."},{"location":"users/datum-filters/op-mode/#expressions","title":"Expressions","text":"<p>See the Expressions section for general expressions reference. The expression must evaluate to  a boolean (<code>true</code> or <code>false</code>) result. When it evaluates to <code>true</code> the configured operational mode will be activated. When it evaluates to <code>false</code> the operational mode will be deactivated (unless an expire setting has been configured).</p> <p>The root object is a datum samples expression object that lets you treat all datum properties, and filter parameters, as expression variables directly, along with the following properties:</p> Property Type Description <code>datum</code> <code>GeneralNodeDatum</code> A <code>GeneralNodeDatum</code> object, populated with data from all property and virtual meter configurations. <code>props</code> <code>Map&lt;String,Object&gt;</code> Simple Map based access to the properties in <code>datum</code>, and transform parameters, to simplify expressions. <p>The following methods are available:</p> Function Arguments Result Description <code>has(name)</code> <code>String</code> <code>boolean</code> Returns <code>true</code> if a property named <code>name</code> is defined."},{"location":"users/datum-filters/op-mode/#expression-examples","title":"Expression examples","text":"<p>Assuming a datum sample with properties like the following:</p> Property Value <code>current</code> <code>7.6</code> <code>voltage</code> <code>240.1</code> <code>status</code> <code>Error</code> <p>Then here are some example expressions and the results they would produce:</p> Expression Result Comment <code>voltage * current &gt; 1800</code> <code>true</code> Since <code>voltage * current</code> is 1824.76, the expression is <code>true</code>. <code>status != 'Error'</code> <code>false</code> Since <code>status</code> is <code>Error</code> the expression is <code>false</code>."},{"location":"users/datum-filters/parameter-expression/","title":"Parameter Expression Datum Filter","text":"<p>The Parameter Expression Datum Filter provides a way to generate filter parameters by evaluating expressions against existing properties. The generated parameters will be available to any further datum filters in the same filter chain.</p> <p>Tip</p> <p>Parameters are useful as temporary variables that you want to use during datum processing but do not want to include as datum properties that get posted to SolarNet.</p> <p>This filter is provided by the Standard Datum Filters plugin.</p>"},{"location":"users/datum-filters/parameter-expression/#settings","title":"Settings","text":"<p>Each filter configuration contains the following overall settings:</p> Setting Description Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Source ID A case-insensitive pattern to match the input source ID(s) to filter. If omitted then datum for all source ID values will be filtered, otherwise only datum with matching source ID values will be filtered. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Expressions A list of expression configurations that are evaluated to derive parameter values from other property values. <p>Use the + and - buttons to add/remove expression configurations.</p>"},{"location":"users/datum-filters/parameter-expression/#expression-settings","title":"Expression settings","text":"<p>Each expression configuration contains the following settings:</p> Setting Description Parameter The filter parameter name to store the expression result in. Expression The expression to evaluate. See below for more info. Expression Language The [expression language][expr-lang] to write Expression in."},{"location":"users/datum-filters/parameter-expression/#expressions","title":"Expressions","text":"<p>See the Expressions section for general expressions reference. This filter supports Datum Expressions that lets you treat all datum properties, and filter parameters, as expression variables directly.</p>"},{"location":"users/datum-filters/property/","title":"Property Datum Filter","text":"<p>The Property Datum Filter provides a way to remove properties of datum. This can help if some component generates properties that you don't actually need to use.</p> <p>For example you might have a plugin that collects data from an AC power meter that capture power, energy, quality, and other properties each time a sample is taken. If you are only interested in capturing the power and energy properties you could use this component to remove all the others.</p> <p>This component can also throttle individual properties over time, so that individual properties are posted less frequently than the rate the whole datum it is a part of is sampled at. For example a plugin for an AC power meter might collect datum once per minute, and you want to collect the energy properties of the datum every minute but the quality properties only once every 10 minutes.</p> <p>The general idea for filtering properties is to configure rules that define which datum sources you want to filter, along with a list of properties to include and/or a list to exclude. All matching is done using regular expressions, which can help make your rules concise.</p> <p>This filter is provided by the Standard Datum Filters plugin.</p>"},{"location":"users/datum-filters/property/#settings","title":"Settings","text":"<p>Each filter configuration contains the following overall settings:</p> Setting Description Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Source ID A case-insensitive pattern to match the input source ID(s) to filter. If omitted then datum for all source ID values will be filtered, otherwise only datum with matching source ID values will be filtered. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Property Includes A list of property names to include, removing all others.  This is a list of case-insensitive patterns to match against datum property names. If any inclusion patterns are configured then only properties matching one of these patterns will be included in datum. Any property name that does not match one of these patterns will be removed. Property Excludes A list of property names to exclude. This is a list of case-insensitive patterns to match against datum property names. If any exclusion expressions are configured then any property that matches one of these expressions will be removed. Exclusion epxressions are processed after inclusion expressions when both are configured. <p>Use the + and - buttons to add/remove property include/exclude patterns.</p> <p>Each property inclusion setting contains the following settings:</p> Setting Description Name The property name pattern to include. Limit Seconds A throttle limit, in seconds, to apply to included properties. The minimum number of seconds to limit properties that match the configured property inclusion pattern. If properties are produced faster than this rate, they will be filtered out. Leave empty (or <code>0</code>) for no throttling."},{"location":"users/datum-filters/split/","title":"Split Datum Filter","text":"<p>The Split Datum Filter provides a way to split the properties of a datum stream into multiple new derived datum streams.</p> <p>This filter is provided by the Standard Datum Filters plugin.</p>"},{"location":"users/datum-filters/split/#settings","title":"Settings","text":"<p>In the example screen shot shown above, the <code>/power/meter/1</code> datum stream is split into two datum streams: <code>/meter/1/power</code> and <code>/meter/1/energy</code>. Properties with names containing <code>current</code>, <code>voltage</code>, or <code>power</code> (case-insensitive) will be copied to <code>/meter/1/power</code>. Properties with names containing <code>hour</code> (case-insensitive) will be copied to <code>/meter/1/energy</code>.</p> <p>Each filter configuration contains the following overall settings:</p> Setting Description Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Source ID A case-insensitive pattern to match the input source ID(s) to filter. If omitted then datum for all source ID values will be filtered, otherwise only datum with matching source ID values will be filtered. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Swallow Input If enabled, then discard input datum after splitting. Otherwise leave the input datum as is. Property Source Mappings A list of property name regular expression with associated source IDs to copy matching properties to."},{"location":"users/datum-filters/split/#property-source-mappings-settings","title":"Property Source Mappings settings","text":"<p>Use the + and - buttons to add/remove Property Source Mapping configurations.</p> <p>Each property source mapping configuration contains the following settings:</p> Setting Description Property A property name case-sensitive regular expression to match on the input datum stream. You can enable case-insensitive matching by including a <code>(?i)</code> prefix. Source ID The destination source ID to copy the matching properties to. Supports placeholders. <p>Tip</p> <p>If multiple property name expressions match the same property name, that property will be copied to all the datum streams of the associated source IDs.</p>"},{"location":"users/datum-filters/tariff/","title":"Time-based Tariff Datum Filter","text":"<p>The Tariff Datum Filter provides a way to inject time-based tariff rates based on a flexible tariff schedule defined with various time constraints.</p> <p>This filter is provided by the Tariff Filter plugin.</p>"},{"location":"users/datum-filters/tariff/#settings","title":"Settings","text":"<p>Each filter configuration contains the following overall settings:</p> Setting Description Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Source ID A case-insensitive pattern to match the input source ID(s) to filter. If omitted then datum for all source ID values will be filtered, otherwise only datum with matching source ID values will be filtered. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Metadata Service The Service Name of the Metadata Service to obtain the tariff schedule from. See below for more information. Metadata Path The metadata path that will resolve the tariff schedule from the configured Metadata Service. Language An IETF BCP 47 language tag to parse the tariff data with. If not configured then the default system language will be assumed. First Match If enabled, then apply only the first tariff that matches a given datum date. If disabled, then apply all tariffs that match. Schedule Cache The amount of seconds to cache the tariff schedule obtained from the configured Metadata Service. Tariff Evaluator The Service Name of a Time-based Tariff Evaluator service to evaluate each tariff to determine if it should apply to a given datum. If not configured a default algorithm is used that matches all non-empty constraints in an inclusive manner, except for the time-of-day constraint which uses an exclusive upper bound."},{"location":"users/datum-filters/tariff/#metadata-service","title":"Metadata Service","text":"<p>SolarNode provides a User Metadata Service component that this filter can use for the Metadata Service setting. This allows you to configure the tariff schedule as user metadata in SolarNetwork and then SolarNode will download the schedule and use it as needed.</p> <p></p> <p>You must configure a SolarNetwork security token to use the User Metadata Service. We recommend that you create a Data security token in SolarNetwork with a limited security policy that includes an API Path of just <code>/users/meta</code> and a User Metadata Path of something granular like <code>/pm/tariffs/**</code>. This will give SolarNode access to just the tariff metadata under the <code>/pm/tariffs</code> metadata path.</p> <p></p> <p>The SolarNetwork API Explorer can be used to add the necessary tariff schedule metadata to your account. For example:</p> <p></p>"},{"location":"users/datum-filters/tariff/#tariff-schedule-format","title":"Tariff schedule format","text":"<p>The tariff schedule obtained from the configured Metadata Service uses a simple CSV-based format that can be easily exported from a spreadsheet. Each row represents a rule that includes:</p> <ul> <li>a set of time constraints that must be satisfied for the rule to be applied</li> <li>a list of tariff rates to be added to datum when the constraints are satisfied</li> </ul> <p>Include a header row</p> <p>A header row is required because the tariff rate names are defined there. The first 4 column names are ignored.</p> <p>The schedule consists of 4 time constraint columns followed by one or more tariff rate columns. Each constraint is represented as a range, in the form <code>start - end</code>. Whitespace is allowed around the <code>-</code> character. If the <code>start</code> and <code>end</code> are the same, the range may be shortened to just <code>start</code>. A range can be left empty to represent all values. The time constraint columns are:</p> Column Constraint Description 1 Month range An inclusive month range. Months can be specified as numbers (1-12) or abbreviations (Jan-Dec) or full names (January - December). When using text names case does not matter and they will be parsed using the Lanauage setting. 2 Day range An inclusive day-of-month range. Days are specified as numbers (1-31). 3 Weekday range An inclusive day-of-week range. Weekdays can be specified as numbers (1-7) with Monday being <code>1</code> and Sunday being <code>7</code>, or abbreviations (Mon-Sun) or full names (Monday - Sunday). When using text names case does not matter and they will be parsed using the Lanauage setting. 4 Time range An inclusive - exclusive time-of-day range. The time can be specified as whole hour numbers (0-24) or <code>HH:MM</code> style (<code>00:00</code> - <code>24:00</code>). <p>Starting on column 5 of the tariff schedule are arbitrary rate values to add to datum when the corresponding constraints are satisfied. The name of the datum property is derived from the header row of the column, adapted according to the following rules:</p> <ol> <li>change to lower case</li> <li>replacing any runs of non-alphanumeric or underscore with a single underscore</li> <li>removing any leading/trailing underscores</li> </ol> <p>Here are some examples of the header name to the equivalent property name:</p> Rate Header Name Datum Property Name TOU <code>tou</code> Foo Bar <code>foo_bar</code> This Isn't A Great Name! <code>this_isn_t_a_great_name</code>"},{"location":"users/datum-filters/tariff/#example-schedule","title":"Example schedule","text":"<p>Here's an example schedule with 4 rules and a single TOU rate (the <code>*</code> stands for all values):</p> Rule Month Day Weekday Time TOU 1 Jan-Dec * Mon-Fri 0-8 10.48 2 Jan-Dec * Mon-Fri 8-24 11.00 3 Jan-Dec * Sat-Sun 0-8 9.19 4 Jan-Dec * Sat-Sun 8-24 11.21 <p>In CSV format the schedule would look like this:</p> <pre><code>Month,Day,Weekday,Time,TOU\nJan-Dec,,Mon-Fri,0-8,10.48\nJan-Dec,,Mon-Fri,8-24,11.00\nJan-Dec,,Sat-Sun,0-8,9.19\nJan-Dec,,Sat-Sun,8-24,11.21\n</code></pre> <p>When encoding into SolarNetwork metadata JSON, that same schedule would look like this when saved at the <code>/pm/tariffs/schedule</code> path:</p> <pre><code>{\n\"pm\": {\n\"tariffs\": {\n\"schedule\": \"Month,Day,Weekday,Time,TOU\\nJan-Dec,,Mon-Fri,0-8,10.48\\nJan-Dec,,Mon-Fri,8-24,11.00\\nJan-Dec,,Sat-Sun,0-8,9.19\\nJan-Dec,,Sat-Sun,8-24,11.21\"\n}\n}\n}\n</code></pre>"},{"location":"users/datum-filters/throttle/","title":"Throttle Datum Filter","text":"<p>The Throttle Datum Filter provides a way to throttle entire datum over time, so that they are posted to SolarNetwork less frequently than a plugin that collects the data produces them. This can be useful if you need a plugin to collect data at a high frequency for use internally by SolarNode but don't need to save such high resolution of data in SolarNetwork. For example, a plugin that monitors a device and responds quickly to changes in the data might be configured to sample data every second, but you only want to capture that data once per minute in SolarNetwork.</p> <p>The general idea for filtering datum is to configure rules that define which datum sources you want to filter, along with time limit to throttle matching datum by. Any datum matching the sources that are captured faster than the time limit will filtered and not uploaded to SolarNetwork.</p> <p>This filter is provided by the Standard Datum Filters plugin.</p>"},{"location":"users/datum-filters/throttle/#settings","title":"Settings","text":"<p>Each filter configuration contains the following overall settings:</p> Setting Description Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Source ID A case-insensitive pattern to match the input source ID(s) to filter. If omitted then datum for all source ID values will be filtered, otherwise only datum with matching source ID values will be filtered. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Limit Seconds A throttle limit, in seconds, to apply to matching datum. The throttle limit is applied to datum by source ID. Before each datum is uploaded to SolarNetwork, the filter will check how long has elapsed since a datum with the same source ID was uploaded. If the elapsed time is less than the configured limit, the datum will not be uploaded."},{"location":"users/datum-filters/unchanged-property/","title":"Unchanged Property Filter","text":"<p>The Unchanged Property Filter provides a way to discard individual datum properties that have not changed within a datum stream.</p> <p>This filter is provided by the Standard Datum Filters plugin.</p> <p>Tip</p> <p>See the Unchanged Datum Filter for a filter that can discard entire unchanging datum (at the source ID level).</p>"},{"location":"users/datum-filters/unchanged-property/#settings","title":"Settings","text":"<p>Each filter configuration contains the following overall settings:</p> Setting Description Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Source ID A case-insensitive pattern to match the input source ID(s) to filter. If omitted then datum for all source ID values will be filtered, otherwise only datum with matching source ID values will be filtered. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Default Unchanged Max Seconds When greater than <code>0</code> then the maximum number of seconds to discard unchanged properties within a single datum stream (source ID). Use this setting to ensure a property is included occasionally, even if the property value has not changed. Having at least one value per hour in a datum stream is recommended. This time period is always relative to the last unfiltered property within a given datum stream seen by the filter. Property Configurations A list of property settings."},{"location":"users/datum-filters/unchanged-property/#property-settings","title":"Property Settings","text":"<p>Use the + and - buttons to add/remove Property configurations.</p> <p>Each property source mapping configuration contains the following settings:</p> Setting Description Property A regular expression pattern to match against datum property names. All matching properties will be filtered. Unchanged Max Seconds When greater than <code>0</code> then the maximum number of seconds to discard unchanged properties within a single datum stream (source ID). This can be used to override the filter-wide Default Unchanged Max Seconds setting, or left blank to use the default value."},{"location":"users/datum-filters/unchanged/","title":"Unchanged Datum Filter","text":"<p>The Unchanged Datum Filter provides a way to discard entire datum that have not changed within a datum stream.</p> <p>This filter is provided by the Standard Datum Filters plugin.</p> <p>Tip</p> <p>See the Unchanged Property Filter for a filter that can discard individual unchanging properties within a datum stream.</p>"},{"location":"users/datum-filters/unchanged/#settings","title":"Settings","text":"<p>Each filter configuration contains the following overall settings:</p> Setting Description Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Source ID A case-insensitive pattern to match the input source ID(s) to filter. If omitted then datum for all source ID values will be filtered, otherwise only datum with matching source ID values will be filtered. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Unchanged Max Seconds When greater than <code>0</code> then the maximum number of seconds to refrain from publishing an unchanged datum within a single datum stream. Use this setting to ensure a datum is included occasionally, even if the datum properties have not changed. Having at least one value per hour in a datum stream is recommended. This time period is always relative to the last unfiltered property within a given datum stream seen by the filter. Property Pattern A property name pattern that limits the properties monitored for changes. Only property names that match this expression will be considered when determining if a datum differs from the previous datum within the datum stream."},{"location":"users/datum-filters/virtual-meter/","title":"Virtual Meter Datum Filter","text":"<p>The Virtual Meter Datum Filter provides a way to derive an accumulating \"meter reading\" value out of an instantaneous property value over time. For example, if you have an irradiance sensor that allows you to capture instantaneous W/m2 power values, you could configure a virtual meter to generate Wh/m2 energy values.</p> <p>Each virtual meter works with a single input datum property, typically an instantaneous property. The derived accumulating datum property will be named after that property with the time unit suffix appended. For example, an instantaneous <code>irradiance</code> property using the <code>Hours</code> time unit would result in an accumulating <code>irradianceHours</code> property. The value is calculated as an average between the current and the previous instantaneous property values, multiplied by the amount of time that has elapsed between the two samples.</p> <p>This filter is provided by the Standard Datum Filters plugin.</p>"},{"location":"users/datum-filters/virtual-meter/#settings","title":"Settings","text":"<p>Each filter configuration contains the following overall settings:</p> Setting Description Service Name A unique ID for the filter, to be referenced by other components. Service Group An optional service group name to assign. Source ID A case-insensitive pattern to match the input source ID(s) to filter. If omitted then datum for all source ID values will be filtered, otherwise only datum with matching source ID values will be filtered. Required Mode If configured, an operational mode that must be active for this filter to be applied. Required Tag Only apply the filter on datum with the given tag. A tag may be prefixed with <code>!</code> to invert the logic so that the filter only applies to datum without the given tag. Multiple tags can be defined using a <code>,</code> delimiter, in which case at least one of the configured tags must match to apply the filter. Virtual Meters Configure as many virtual meters as you like, using the + and - buttons to add/remove meter configurations."},{"location":"users/datum-filters/virtual-meter/#virtual-meter-settings","title":"Virtual Meter Settings","text":"<p>The Virtual Meter settings define a single virutal meter.</p> <p></p> Setting Description Property The name of the input datum property to derive the virtual meter values from. Property Type The type of the input datum property. Typically this will be <code>Instantaneous</code> but when combined with an expression an <code>Accumulating</code> property can be used. Reading Property The name of the output meter accumulating datum property to generate. Leave empty for a default name derived from Property and Time Unit. For example, an instantaneous <code>irradiance</code> property using the <code>Hours</code> time unit would result in an accumulating <code>irradianceHours</code> property. Time Unit The time unit to record meter readings as. This value affects the name of the virtual meter reading property if Reading Property is left blank: it will be appended to the end of Property Name. It also affects the virtual meter output reading values, as they will be calculated in this time unit. Max Age The maximum time allowed between samples where the meter reading can advance. In case the node is not collecting samples for a period of time, this setting prevents the plugin from calculating an unexpectedly large reading value jump. For example if a node was turned off for a day, the first sample it captures when turned back on would otherwise advance the reading as if the associated instantaneous property had been active over that entire time. With this restriction, the node will record the new sample date and value, but not advance the meter reading until another sample is captured within this time period. Decimal Scale A maximum number of digits after the decimal point to round to. Set to <code>0</code> to round to whole numbers. Track Only On Change When enabled, then only update the previous reading date if the new reading value differs from the previous one. Rolling Average Count A count of samples to average the property value from. When set to something greater than <code>1</code>, then apply a rolling average of this many property samples and output that value as the instantaneous source property value. This has the effect of smoothing the instantaneous values to an average over the  time period leading into each output sample. Defaults to <code>0</code> so no rolling average is applied. Add Instantaneous Difference When enabled, then include an output instantaneous property of the difference between the current and previous reading values. Instantaneous Difference Property The derived output instantaneous datum property name to use when Add Instantaneous Difference is enabled. By default this property will be derived from the Reading Property value with <code>Diff</code> appended. Reading Value You can reset the virtual meter reading value with this setting.  Note this is an advanced operation. If you submit a value for this setting, the virtual meter reading will be reset to this value such that the next datum the reading is calculated for will use this as the current meter reading. This will impact the datum stream's reported aggregate values, so you should be very sure this is something you want to do. For example if the virtual meter was at <code>1000</code> and you reset it <code>0</code> then that will appear as a <code>-1000</code> drop in whatever the reading is measuring. If this occurs you can create a <code>Reset</code> Datum auxiliary record to accomodate the reset value. Expressions Configure as many expressions as you like, using the + and - buttons to add/remove expression configurations."},{"location":"users/datum-filters/virtual-meter/#virtual-meter-expression-settings","title":"Virtual Meter Expression Settings","text":"<p>A virtual meter can use expressions to customise how the output meter value reading value is calculated. See the Expressions section for more information.</p> <p></p> Setting Description Property The datum property to store the expression result in. This must match the Reading Property of a meter configuration. Keep in mind that if Reading Property is blank, the implied value is derived from Property and Time Unit. Property Type The datum property type to use. Expression The expression to evaluate. See below for more info. Expression Language The expression language to write Expression in."},{"location":"users/datum-filters/virtual-meter/#filter-parameters","title":"Filter parameters","text":"<p>When the virtual meter filter is applied to a given datum, it will generate the following filter parameters, which will be available to other filters that are applied to the same datum after this filter.</p> Parameter Description <code>{inputPropertyName}_diff</code> The difference between the current input property value and the previous input property value. The <code>{inputPropertyName}</code> part of the parameter name will be replaced by the actual input property name. For example <code>irradiance_diff</code>. <code>{meterPropertyName}_diff</code> The difference between the current output meter property value and the previous output meter property value. The <code>{meterPropertyName}</code> part of the parameter name will be replaced by the actual output meter property name. For example <code>irradianceHours_diff</code>."},{"location":"users/datum-filters/virtual-meter/#expressions","title":"Expressions","text":"<p>Expressions can be configured to calculate the output meter datum property, instead of using the default averaging algorithm. If an expression configuration exists with a Property that matches a configured (or implied) meter configuration Reading Property, then the expression will be invoked to generate the new meter reading value. See the Expressions guide for general expression language reference.</p> <p>Warning</p> <p>It is important to remember that the expression must calculate the next meter reading value. Typically this means it will calculate some differential value based on the amount of time that has elapsed and add that to the previous meter reading value.</p>"},{"location":"users/datum-filters/virtual-meter/#expression-root-object","title":"Expression root object","text":"<p>The root object is a virtual meter expression object that lets you treat all datum properties, and filter parameters, as expression variables directly, along with the following properties:</p> Property Type Description <code>config</code> <code>VirtualMeterConfig</code> A <code>VirtualMeterConfig</code> object for the virtual meter configuration the expression is evaluating for. <code>datum</code> <code>GeneralNodeDatum</code> A <code>Datum</code> object, populated with data from all property and virtual meter configurations. <code>props</code> <code>Map&lt;String,Object&gt;</code> Simple Map based access to the properties in <code>datum</code>, and transform parameters, to simplify expressions. <code>currDate</code> <code>long</code> The current datum timestamp, as a millisecond epoch number. <code>prevDate</code> <code>long</code> The previous datum timestamp, as a millisecond epoch number. <code>timeUnits</code> <code>decimal</code> A decimal number of the difference between <code>currDate</code> and <code>prevDate</code> in the virtual meter configuration's Time Unit, rounded to at most 12 decimal digits. <code>currInput</code> <code>decimal</code> The current input property value. <code>prevInput</code> <code>decimal</code> The previous input property value. <code>inputDiff</code> <code>decimal</code> The difference between the <code>currInput</code> and <code>prevInput</code> values. <code>prevReading</code> <code>decimal</code> The previous output meter property value. <p>The following methods are available:</p> Function Arguments Result Description <code>has(name)</code> <code>String</code> <code>boolean</code> Returns <code>true</code> if a property named <code>name</code> is defined. <code>timeUnits(scale)</code> <code>int</code> <code>decimal</code> Like the <code>timeUnits</code> property but rounded to a specific number of decimal digits."},{"location":"users/datum-filters/virtual-meter/#expression-example-time-of-use-tariff-reading","title":"Expression example: time of use tariff reading","text":"<p>Iagine you'd like to track a time-of-use cost associated with the energy readings captured by an energy meter. The Time-based Tariff Datum Filter filter could be used to add a <code>tou</code> property to each datum, and then a virtual meter expression can be used to calculate a <code>cost</code> reading property. The <code>cost</code> property will be an accumulating property like any meter reading, so when SolarNetwork aggregates its value over time you will see the effective cost over each aggregate time period.</p> <p>Here is a screen shot of the settings used for this scenario (note how the Reading Property value matches the Expression Property value):</p> <p></p> <p>The important settings to note are:</p> Setting Notes Virtual Meter - Property The input datum property is set to <code>wattHours</code> because we want to track changes in this property over time. Virtual Meter - Property Type We use <code>Accumulating</code> here because that is the type of property <code>wattHours</code> is. Virtual Meter - Reading Property The output reading property name. This must match the Expression - Property setting. Expression - Property This must match the Virtual Meter - Reading Property we want to evaluate the expression for. Expression - Property Type Typically this should be <code>Accumulating</code> since we are generating a meter reading style property. Expression - Expression The expression to evaluate. This expression looks for the <code>tou</code> property and when found the meter reading is incremented by the difference between the current and previous input <code>wattHours</code> property values multiplied by <code>tou</code>. If <code>tou</code> is not available, then the previous meter reading value is returned (leaving the reading unchanged). <p>Assuming a datum sample with properties like the following:</p> Property Value <code>tou</code> <code>11.00</code> <code>currDate</code> <code>1621380669005</code> <code>prevDate</code> <code>1621380609005</code> <code>timeUnits</code> <code>0.016666666667</code> <code>currInput</code> <code>6095574</code> <code>prevInput</code> <code>6095462</code> <code>inputDiff</code> <code>112</code> <code>prevReading</code> <code>1022.782</code> <p>Then here are some example expressions and the results they would produce:</p> Expression Result Comment <code>inputDiff / 1000</code> <code>0.112</code> Convert the input Wh property difference to kWh. <code>inputDiff / 1000 * tou</code> <code>1.232</code> Multiply the input kWh by the the $/kWh tariff value to calculate the cost for the elapsed time period. <code>prevReading + (inputDiff / 1000 * tou)</code> <code>1,024.014</code> Add the additional cost to the previous meter reading value to reach the new meter value."},{"location":"users/setup-app/","title":"Setup App","text":"<p>The SolarNode Setup App allows you to manage SolarNode through a web browser.</p> <p>To access the Setup App, you need to know the network address of your SolarNode. In many cases you can try accessing http://solarnode/. If that does not work, you need to find the network address SolarNode is using.</p> <p>Here is an example screen shot of the SolarNode Setup App:</p> <p></p>"},{"location":"users/setup-app/certificates/","title":"Certificates","text":"<p>TODO</p> <p></p>"},{"location":"users/setup-app/home/","title":"Home","text":"<p>TODO</p> <p></p>"},{"location":"users/setup-app/login/","title":"Login","text":"<p>You must log in to SolarNode to access its functions. The login credentials will have been created when you first set up SolarNode and associated it with your SolarNetwork account. The default Username will be your SolarNetwork account email address, and the password will have been randomly generated and shown to you.</p> <p>Tip</p> <p>You can change your SolarNode username and password after logging in. Note these credentials are not related, or tied to, your SolarNetwork login credentials.</p> <p></p>"},{"location":"users/setup-app/plugins/","title":"Plugins","text":"<p>TODO</p>"},{"location":"users/setup-app/profile/","title":"Profile","text":"<p>The profile menu in the top-right of the Setup App menu give you access to change  you password, change  you username, logout, restart, and reset SolarNode.</p> <p>Tip</p> <p>Your SolarNode credentials are not related, or tied to, your SolarNetwork login credentials. Changing your SolarNode username or password does not change your SolarNetwork credentials.</p> <p> </p> <p>The profile menu in SolarNode</p>"},{"location":"users/setup-app/profile/#change-password","title":"Change Password","text":"<p>Choosing the Change Password menu item will take you to a form for changing your password. Fill in your current password and then your new password, then click the Submit Password button.</p> <p> </p> <p>The Change Password form</p> <p>As a result, you will stay on the same page, but a success (or error) message will be shown above the form:</p> <p></p>"},{"location":"users/setup-app/profile/#change-username","title":"Change Username","text":"<p>Choosing the Change Username menu item will take you to a form for changing your SolarNode username. Fill in your current password and then your new password, then click the Change Username button.</p> <p> </p> <p>The Change Username form</p> <p>As a result, you will stay on the same page, but a success (or error) message will be shown above the form:</p> <p></p>"},{"location":"users/setup-app/profile/#logout","title":"Logout","text":"<p>Choosing the Logout menu item will immediately end your SolarNode session and log you out. You will ned to log in again to use the Setup App further.</p>"},{"location":"users/setup-app/profile/#restart","title":"Restart","text":"<p>You can either restart or reboot SolarNode from the Restart SolarNode menu. A restart means the SolarNode app will restart, while a reboot means the entire SolarNodeOS device will shut down and boot up again (restarting SolarNode along the way).</p> <p>You might need to restart SolarNode to pick up new plugins you've installed, and you might need to reboot SolarNode if you've attached new sensors or other devices that require operating system support.</p> <p> </p> <p>The Restart SolarNode menu brings up this dialog.</p>"},{"location":"users/setup-app/profile/#reset","title":"Reset","text":"<p>You can perform a \"factory reset\" of SolarNode to remove all your custom settings, certificate, login credentials, and so on. You also have the option to preserve some SolarNodeOS settings like WiFi credentials if you like.</p> <p> </p> <p>The Reset SolarNode menu brings up this dialog.</p>"},{"location":"users/setup-app/settings/","title":"Settings","text":"<p>The Settings page in SolarNode Setup is where you can configure all available SolarNode settings. The page is divided 4 main sections, outlined next.</p>"},{"location":"users/setup-app/settings/#components","title":"Components","text":"<p>The Components section lists all the configurable multi-instance components available on your SolarNode. Multi-instance means you can configure any number of a given component, each with their own settings.</p> <p>For example imagine you want to collect data from a power meter, solar inverter, and weather station, all of which use the Modbus protocol. To do that you would configure three instances of the Modbus Device component, one for each device.</p> <p>Use the Manage button for any listed compoennt to add or remove instances of that component.</p> <p>An instance count badge appears next to any component with at least one instance configured.</p> <p></p>"},{"location":"users/setup-app/settings/#settings_1","title":"Settings","text":"<p>Other configurable services that are not Components appear in the Settings section.</p> <p>Each setting will include a  button that will show you a brief description of that setting.</p> <p></p> <p>After making any change, an Active value label will appear, showing the currently active value for that setting.</p> <p></p> <p>In order to save your changes, you must click the Save All Changes button. You may need to scroll the page to find it!</p> <p></p>"},{"location":"users/setup-app/settings/#backup-restore","title":"Backup &amp; Restore","text":"<p>The Backup &amp; Restore section lets you manage SolarNode backups. Each backup contains a snapshot of the settings you have configured, the node's certificate, and custom plugins.</p> <p></p>"},{"location":"users/setup-app/settings/#file-system-backup-service","title":"File System Backup Service","text":"<p>The File System Backup Service is the default Backup Service provided by SolarNode. It saves the backup onto the node itself. In order to be able to restore your settings if the node is damaged or lost, you must download a copy of a backup using the Download button, and save the file to a safe place.</p> <p>Warning</p> <p>If you do not download a copy of a backup, you run the risk of losing your settings and node certificate, making it impossible to restore the node in the event of a catastrophic hardware failure.</p> <p>The configurable settings of the File System Backup Service are:</p> Setting Description Backup Directory The folder (on the node) where the backups will be saved. Copies The number of backup copies to keep, before deleting the oldest backup."},{"location":"users/setup-app/settings/#s3-backup-service","title":"S3 Backup Service","text":"<p>The S3 Backup Service creates cloud-based backups in AWS S3 (or any compatible provider). You must configure the credentials and S3 location details to use before any backups can be created.</p> <p></p> <p>Note</p> <p>The S3 Backup Service requires the S3 Backup Service Plugin.</p> <p>The configurable settings of the S3 Backup Service are:</p> Setting Description AWS Token The AWS access token to authenticate with. AWS Secret The AWS access token secret to authenticate with. AWS Region The name of the Amazon region to use, for example <code>us-west-2</code>. S3 Bucket The name of the S3 bucket to use. S3 Path An optional root path to use for all backup data (typically a folder location). Storage Class A supported storage class, such as STANDARD (the default), <code>STANDARD_IA</code>, <code>INTELLIGENT_TIERING</code>, <code>REDUCED_REDUNDANCY</code>, and so on. Copies The number of backup copies to keep, before deleting the oldest backup. Cache Seconds The amount of time to cache backup metadata such as the list of available backups, in seconds."},{"location":"users/setup-app/settings/#settings-backup-restore","title":"Settings Backup &amp; Restore","text":"<p>The Settings Backup &amp; Restore section provides a way to manage Settings Files and Settings Resources, both of which are backups for the configured settings in SolarNode.</p> <p>Warning</p> <p>Settings Files and Settings Resources do not include the node's certificate or custom plugins. See the Backup &amp; Restore section for managing \"full\" backups that do include those items.</p> <p></p> <p>The Export button allows you to download a Settings File with the currently active configuration.</p> <p>The Import button allows you to upload a previously-downloaded Settings File.</p> <p>The Settings Resource menu and associated Export to file button allow you to download specialized settings files, offered by some components in SolarNode.</p> <p>The Auto backups area will have a list of buttons, each of which will let you download a Settings File that SolarNode automatically created. Each button shows you the date the settings backup was created.</p>"},{"location":"users/setup-app/settings/datum-filters/","title":"Datum Filters","text":"<p>Datum Filters are services that manipulate datum generated by SolarNode plugins before they are uploaded to SolarNet. See the general Datum Filters section for more information about how datum filters work and what they are used for.</p>"},{"location":"users/setup-app/settings/datum-filters/#global-datum-filters","title":"Global Datum Filters","text":"<p>Global Datum Filters are applied to datum just before posting to SolarNetwork. Once an instance is created, it is automatically active and will be applied to datum. This differs from User Datum Filters, which must be explicitly added to a service to be used, either dircectly or indirectly with a Datum Filter Chain.</p> <p></p> <p>Click the Manage button next to any Global Datum Filter component to create, update, and remove instances of that filter.</p>"},{"location":"users/setup-app/settings/datum-filters/#datum-queue","title":"Datum Queue","text":"<p>All datum generated by SolarNode plugins are added to the Datum Queue for processing. The datum are processed in the order they are added to the queue. Datum Filters are applied to each datum, each filter's result passed to the next available filter until all filters have been applied.</p> <p>The Datum Queue section of the Datum Filters page shows you some processing statistics and has a couple of settings you can change:</p> <p></p> Setting Description Delay The minimum amount of time to delay processing datum after they have been added to the queue, in milliseconds. A small amount of delay allows parallel datum collection to get processed more reliably in time-based order. The default is 200 ms and usually does not need to be changed. Datum Filter The Service Name of a Datum Filter component to process datum with. See below for more information. <p>The Datum Filter setting allows you to configure a single Datum Filter to apply to every datum captured in SolarNode. Since you can only configure one filter, it is very common to configure a Datum Filter Chain, where you can then configure any number of other filters to apply.</p> <p></p>"},{"location":"users/setup-app/settings/datum-filters/#global-datum-filter-chain","title":"Global Datum Filter Chain","text":"<p>The Global Datum Filter Chain provides a way to apply explicit User Datum Filters to datum just before posting to SolarNetwork.</p> <p></p> Setting Description Active Global Filters A read-only list of any created Global Datum Filter component Service Name values. These filters are automatically applied, without needing to explicitly reference them in the Datum Filters list. Available User Filters A read-only list of Service Name values of User Datum Filter components that have been configured. You can copy any value from this list and paste it into the Datum Filters list to activate that filter. Datum Filters The list of Service Name values of User Datum Filter components to apply to datum."},{"location":"users/setup-app/settings/datum-filters/#user-datum-filters","title":"User Datum Filters","text":"<p>User Datum Filters are not applied automatically: they must be explicitly added to a service to be used, either dircectly or indirectly with a Datum Filter Chain. This differs from Global Datum Filters which are automatically applied to datum just before being uploaded to SolarNet.</p> <p></p> <p>Click the Manage button next to any User Datum Filter component to create, update, and remove instances of that filter.</p>"},{"location":"users/setup-app/settings/logging/","title":"Logging","text":"<p>The SolarNode UI supports configuring logger levels dynamically, without having to change the logging configuration file.</p> <p>Warning</p> <p>When SolarNode restarts all changes made in the Logger UI will be lost and the logger configuration will revert to whatever is configured in the logging configuration file.</p> <p></p> <p>The Logging page lists all the configured logger levels and lets you add new loggers and edit the existing ones using a simple form.</p> <p></p>"},{"location":"users/setup-app/settings/manage-component/","title":"Manage Component","text":"<p>The component management page is shown when you click the Manage button for a multi-instance component. Each component instance's settings are independent, allowing you to integrate with multiple copies of a device or service.</p> <p>For example if you connected a Modbus power meter and a Modbus solar inverter to a node, you would create two Modbus Device component instances, and configure them with settings appropriate for each device.</p> <p> The component management screen allows you to add, update, and remove component instances.</p>"},{"location":"users/setup-app/settings/manage-component/#add-new-instance","title":"Add new instance","text":"<p>Add new component instances by clicking the Add new X button in the top-right, where X is the name of the component you are managing. You will be given the opportunity to assign a unique identifier to the new component instance:</p> <p> When creating a new component instance you can provide a short name to identify it with.</p> <p>When you add more than one component instance, the identifiers appear as clickable buttons that allow you to switch between the setting forms for each component.</p> <p> Component instance buttons let you switch between each component instance.</p>"},{"location":"users/setup-app/settings/manage-component/#saving-changes","title":"Saving changes","text":"<p>After making changes to any component instance's settings, the Save All Changes button in the top-left.</p> <p>Save All Changes works across all component instances</p> <p>You can safely switch between and make changes on multiple component instance settings before clicking the Save All Changes button: your changes across all instances will be saved.</p>"},{"location":"users/setup-app/settings/manage-component/#remove-or-reset-instances","title":"Remove or reset instances","text":"<p>At the bottom of each component instance are buttons that let you delete or reset that component intance.</p> <p> Buttons to delete or reset component instance.</p> <p>The Delete button will remove that component instance from appearing, however the settings associated with that instance are preserved. If you re-add an instance with the same identifier then the previous settings will be restored. You can think of the Delete button as disabling the component, giving you the option to \"undo\" the deletion if you like.</p> <p>The Restore button will reset the component to its factory defaults, removing any settings you have customized on that instance. The instance remains visible and you can re-configure the settings as needed.</p>"},{"location":"users/setup-app/settings/manage-component/#remove-all-instances","title":"Remove all instances","text":"<p>The Remove all button in the top-right of the page allows you to remove all component instances, including any customized settings on those instances.</p>"},{"location":"users/setup-app/settings/op-modes/","title":"Operational Modes","text":"<p>The SolarNode UI will show the list of active Operational Modes on the Settings &gt; Operational Modes page. Click the + button to activate modes, and the  button to deactivate an active mode.</p> <p></p> <p>The main Settings page also shows a read-only view of the active modes:</p> <p></p>"},{"location":"users/setup-app/tools/","title":"Tools","text":"<p>TODO</p>"},{"location":"users/setup-app/tools/command-console/","title":"Command Console","text":"<p>SolarNode includes a Command Console page where troubleshooting commands from supporting plugins are displayed. The page shows a list of available command topics and lets you toggle the inclusion of each topic's commands at the bottom of the page.</p> <p></p>"},{"location":"users/setup-app/tools/command-console/#modbus-commands","title":"Modbus Commands","text":"<p>The Modbus TCP Connection and Modbus Serial Connection components support publishing mbpoll commands under a modbus command topic. The <code>mbpoll</code> utility is included in SolarNodeOS; if not already installed you can install it by logging in to the SolarNodeOS shell and running the following command:</p> <pre><code>sudo apt install mbpoll\n</code></pre> <p>Modbus command logging must be enabled on each Modbus Connection component by toggling the CLI Publishing setting on.</p> <p></p> <p>Once CLI Publishing has been enabled, every Modbus request made on that connection will generate an equivalent <code>mbpoll</code> command, and those commands will be shown on the Command Console.</p> <p></p> <p>You can copy any logged command and paste that into a SolarNodeOS shell to execute the Modbus request and see the results.</p> <pre><code>mbpoll -g -0 -1 -m rtu -b 4800 -s 1 -P none -a 1 -o 5 -t 4:hex -r 0 -c 2 /dev/tty.usbserial-FTYS9FWO\n-- Polling slave 1...\n[0000]:     0x00FC\n[0001]:     0x0A1F\n</code></pre>"},{"location":"users/setup-app/tools/controls/","title":"Controls","text":"<p>TODO</p> <p></p> <p></p>"},{"location":"users/sysadmin/","title":"System Administration","text":"<p>SolarNode runs on SolarNodeOS, a Debian Linux-based operating system. If you are already familiar with Debian Linux, or one of the other Linux distributions built from Debian like Ubuntu Linux, you will find it pretty easy to get around in SolarNodeOS.</p>"},{"location":"users/sysadmin/#system-user-account","title":"System User Account","text":"<p>SolarNodeOS ships with a <code>solar</code> user account that you can use to log into the operating system. The default password is <code>solar</code> but may have been changed by a system administrator.</p> <p>Warning</p> <p>The <code>solar</code> user account is not related to the account you log into the SolarNode Setup App with.</p>"},{"location":"users/sysadmin/#change-system-user-account-password","title":"Change system user account password","text":"<p>To change the system user account's password, use the <code>passwd</code> command.</p> Changing the system user account password<pre><code>$ passwd\nChanging password for solar.\nCurrent password:\nNew password:\nRetype new password:\npasswd: password updated successfully\n</code></pre> <p>Tip</p> <p>Changing the <code>solar</code> user's password is highly recommended when you first deploy a node.</p>"},{"location":"users/sysadmin/#administrator-access","title":"Administrator Access","text":"<p>Some commands require administrative permission. The <code>solar</code> user can execute arbitrary commands with administrative permission by prefixing the command with <code>sudo</code>. For example the <code>reboot</code> command will reboot SolarNodeOS, but requires administrative permission.</p> Run a command as a system administrator<pre><code>$ sudo reboot\n</code></pre> <p>The <code>sudo</code> command will prompt you for the <code>solar</code> user's password and then execute the given command as the administrator user <code>root</code>.</p> <p>The <code>solar</code> user can also become the <code>root</code> administrator user by way of the <code>su</code> command:</p> Gain system administrative privledges with su<pre><code>$ sudo su -\n</code></pre> <p>Once you have become the <code>root</code> user you no longer need to use the <code>sudo</code> command, as you already have administrative permissions.</p>"},{"location":"users/sysadmin/#network-access-with-ssh","title":"Network Access with SSH","text":"<p>SolarNodeOS comes with an SSH service active, which allows you to remotely connect and access the command line, using any SSH client.</p>"},{"location":"users/sysadmin/date-time/","title":"Date and Time","text":"<p>SolarNodeOS includes date and time management functions through the timedatectl command. Run <code>timedatectl status</code> to view information about the current date and time settings.</p> Viewing the current date and time settings<pre><code>$ timedatectl status\n               Local time: Fri 2023-05-26 03:41:42 BST\n           Universal time: Fri 2023-05-26 02:41:42 UTC\n                 RTC time: n/a\n                Time zone: Europe/London (BST, +0100)\nSystem clock synchronized: yes\n              NTP service: active\n          RTC in local TZ: no\n</code></pre>"},{"location":"users/sysadmin/date-time/#changing-the-local-time-zone","title":"Changing the local time zone","text":"<p>SolarNodeOS uses the <code>UTC</code> time zone by default. If you would like to change this, use the <code>timedatectl set-timezone</code></p> Changing the local time zone<pre><code>$ sudo timedatectl set-timezone Pacific/Auckland\n</code></pre> <p>You can list the available time zone names by running <code>timedatectl list-timezones</code>.</p>"},{"location":"users/sysadmin/date-time/#internet-time-synchronization","title":"Internet time synchronization","text":"<p>SolarNodeOS uses the systemd-timesyncd service to synchronize the node's clock with internet time servers. Normally no configuration is necessary. You can check the status of the network time synchronization with timedatectl like:</p> <pre><code>$ timedatectl status\n               Local time: Fri 2023-05-26 03:41:42 BST\n           Universal time: Fri 2023-05-26 02:41:42 UTC\n                 RTC time: n/a\n                Time zone: Europe/London (BST, +0100)\nSystem clock synchronized: yes\n              NTP service: active\n          RTC in local TZ: no\n</code></pre> <p>Warning</p> <p>For internet time synchronization to work, SolarNode needs to access Network Time Protocol (NTP) servers, using UDP over port 123.</p>"},{"location":"users/sysadmin/date-time/#network-time-server-configuration","title":"Network time server configuration","text":"<p>The NTP servers that SolarNodeOS uses are configured in the /etc/systemd/timesyncd.conf file. The default configuration uses a pool of Debian servers, which should be suitable for most nodes. If you would like to change the configuration, edit the <code>timesyncd.conf</code> file and change the <code>NTP=</code> line, for example</p> Configuring the NTP servers to use<pre><code>[Time]\nNTP=my.ntp.example.com\n</code></pre>"},{"location":"users/sysadmin/date-time/#setting-the-date-and-time","title":"Setting the date and time","text":"<p>In order to manually set the date and time, NTP time synchronization must be disabled with <code>timedatectl set-ntp false</code>. Then you can run <code>timedatectl set-time</code> to set the date:</p> Manually changing the date and time<pre><code>$ sudo timedatectl set-ntp false\n$ sudo timedatectl set-time \"2023-05-26 17:30:00\"\n</code></pre> <p>If you then look at the <code>timedatectl status</code> you will see that NTP has been disabled:</p> Status with NTP disabled<pre><code>$ timedatectl\n               Local time: Fri 2023-05-26 17:30:30 NZST\n           Universal time: Fri 2023-05-26 05:30:30 UTC\n                 RTC time: n/a\n                Time zone: Pacific/Auckland (NZST, +1200)\nSystem clock synchronized: no # (1)!\nNTP service: inactive # (2)!\nRTC in local TZ: no\n</code></pre> <ol> <li>The clock is not synchronized with internet time servers, as it shows no</li> <li>The NTP service has been disabled, as it is listed as inactive</li> </ol> <p>You can re-enable NTP time synchronization like this:</p> Enabling NTP time synchronization<pre><code>$ sudo timedatectl set-ntp true\n</code></pre>"},{"location":"users/sysadmin/networking/","title":"Networking","text":"<p>SolarNodeOS uses the systemd-networkd service to manage network devices and their settings. A network device relates to a physical network hardware device or a software networking component, as recognized and named by the operating system. For example, the first available ethernet device is typically named <code>eth0</code> and the first available WiFi device <code>wlan0</code>.</p>"},{"location":"users/sysadmin/networking/#network-configuration","title":"Network configuration","text":"<p>Network configuration is stored in <code>.network</code> files in the <code>/etc/systemd/network</code> directory. SolarNodeOS comes with default support for ethernet and WiFi network devices.</p> <p>The default <code>10-eth.network</code> file configures the default ethernet network <code>eth0</code> to use DHCP to automatically obtain a network address, routing information, and DNS servers to use.</p>"},{"location":"users/sysadmin/networking/#dhcp-configuration","title":"DHCP configuration","text":"<p>SolarNodeOS networks are configured to use DHCP by default. If you need to re-configure a network to use DHCP, change the configuration to look like this:</p> Ethernet network with DHCP configuration<pre><code>[Match]\nName=eth0\n\n[Network]\nDHCP=yes\n</code></pre> <p>Use a Name value specific to your network.</p>"},{"location":"users/sysadmin/networking/#static-network-configuration","title":"Static network configuration","text":"<p>If you need to use a static network address, instead of DHCP, edit the network configuration file (for example, the <code>10-eth.network</code> file for the ethernet network), and change it to look like this:</p> Ethernet network with static address configuration<pre><code>[Match]\nName=eth0\n\n[Network]\nDNS=1.1.1.1\n\n[Address]\nAddress=192.168.3.10/24\n\n[Route]\nGateway=192.168.3.1\n</code></pre> <p>Use Name, DNS, Address, and Gateway values specific to your network. The same static configuration for a single address can also be specified in a slightly more condensed form, moving everything into the <code>[Network]</code> section:</p> Ethernet network with condensed single static address configuration<pre><code>[Match]\nName=eth0\n\n[Network]\nAddress=192.168.3.10/24\nGateway=192.168.3.1\nDNS=1.1.1.1\n</code></pre>"},{"location":"users/sysadmin/networking/#wifi-network-configuration","title":"WiFi network configuration","text":"<p>The default <code>20-wlan.network</code> file configures the default WiFi network <code>wlan0</code> to use DHCP to automatically obtain a network address, routing information, and DNS servers to use. To configure the WiFi network SolarNode should connect to, run this command:</p> Configuring the SolarNode WiFi network<pre><code>sudo dpkg-reconfigure sn-wifi\n</code></pre> <p>You will then be prompted to supply the following WiFi settings:</p> <ol> <li>Country code, e.g. <code>NZ</code></li> <li>WiFi network name (SSID)</li> <li>WiFi network password</li> </ol> <p>Note about WiFi support</p> <p>WiFi support is provided by the <code>sn-wifi</code> package, which may not be installed. See the Package Maintenance section for information about installing packages.</p>"},{"location":"users/sysadmin/networking/#wifi-auto-access-point-mode","title":"WiFi Auto Access Point mode","text":"<p>For initial setup of a the WiFi settings on a SolarNode it can be helpful for SolarNode to create its own WiFi network, as an access point. The <code>sn-wifi-autoap@wlan0</code> service can be used for this. When enabled, it will monitor the WiFi network status, and when the WiFi connection fails for any reason it will enable a <code>SolarNode</code> WiFi network using a gateway IP address of <code>192.168.16.1</code>. Thus when the SolarNode access point is enabled, you can connect to that network from your own device and reach the Setup App at <code>http://192.168.16.1/</code> or the command line via <code>ssh solar@192.168.16.1</code>.</p> <p>The default <code>21-wlan-ap.network</code> file configures the default WiFi network <code>wlan0</code> to act as an Access Point</p> <p>This service is not enabled by default. To enable it, run the following:</p> <pre><code>sudo systemctl enable --now sn-wifi-autoap@wlan0\n</code></pre> <p>Once enabled, if SolarNode cannot connect to the configured WiFi network, it will create its own <code>SolarNode</code> network. By default the password for this network is <code>solarnode</code>. The Access Point network configuration is defined in the <code>/etc/network/wpa_supplicant-wlan0.conf</code> file, in a section like this:</p> <pre><code>### access-point mode\nnetwork={\n    ssid=\"SolarNode\"\n    mode=2\n    key_mgmt=WPA-PSK\n    psk=\"solarnode\"\n    frequency=2462\n}\n</code></pre>"},{"location":"users/sysadmin/packages/","title":"Package Maintenance","text":"<p>SolarNodeOS supports a wide variety of software packages. You can install new packages as well as apply package updates as they become available. The apt command performs these tasks.</p>"},{"location":"users/sysadmin/packages/#update-package-metadata","title":"Update package metadata","text":"<p>For SolarNodeOS to know what packages, or package updates, are available, you need to periodically update the available package information. This is done with the <code>apt update</code> command:</p> Update package information<pre><code>sudo apt update # (1)!\n</code></pre> <ol> <li>The <code>sudo</code> command runs other commands with administrative privledges.    It will prompt you for your user account password (typically the <code>solar</code> user).</li> </ol>"},{"location":"users/sysadmin/packages/#list-installed-packages","title":"List installed packages","text":"<p>Use the <code>apt list</code> command to list the installed packages:</p> Listing the installed packages<pre><code>apt list --installed\n</code></pre>"},{"location":"users/sysadmin/packages/#update-packages","title":"Update packages","text":"<p>To see if there are any package updates available, run <code>apt list</code> like this:</p> List packages with updates available<pre><code>apt list --upgradable\n</code></pre> <p>If there are updates available, that will show them. You can apply all package updates with the <code>apt upgrade</code> command, like this:</p> Upgrade all packages<pre><code>sudo apt upgrade\n</code></pre> <p>If you want to install an update for a specific package, use the <code>apt install</code> command instead.</p> <p>Tip</p> <p>The <code>apt upgrade</code> command will update existing packages and install packages that are required by those packages, but it will never remove an existing package. Sometimes you will want to allow packages to be removed during the upgrade process; to do that use the <code>apt full-upgrade</code> command.</p>"},{"location":"users/sysadmin/packages/#search-for-packages","title":"Search for packages","text":"<p>Use the <code>apt search</code> command to search for packages. By default this will match package names and their descriptions. You can search just for package names by including a <code>--names-only</code> argument.</p> Search for packages<pre><code># search for \"name\" across package names and descriptions\napt search name\n\n# search for \"name\" across package names only\napt search --names-only name\n\n# multiple search terms are logically \"and\"-ed together\napt search name1 name2\n</code></pre>"},{"location":"users/sysadmin/packages/#install-packages","title":"Install packages","text":"<p>The <code>apt install</code> command will install an available package, or an individual package update.</p> Install package<pre><code>sudo apt install mypackage\n</code></pre>"},{"location":"users/sysadmin/packages/#remove-packages","title":"Remove packages","text":"<p>You can remove packages with the <code>apt remove</code> command. That command will preserve any system configuration associated with the package(s); if you would like to also remove that you can use the <code>apt purge</code> command.</p> Removing packages<pre><code>sudo apt remove mypackage\n\n# use `purge` to also remove configuration\nsudo apt purge mypackage\n</code></pre>"},{"location":"users/sysadmin/solarnode-service/","title":"SolarNode Service","text":"<p>SolarNode is managed as a systemd service. There are some shortcut commands to more easily manage the service.</p> Command Description <code>sn-start</code> Start the SolarNode service. <code>sn-restart</code> Restart the SolarNode service. <code>sn-status</code> View status information about the SolarNode service (see if it is running or not). <code>sn-stop</code> Stop the SolarNode service. <p>The <code>sn-stop</code> command requires administrative permissions, so you may be prompted for your system account password (usually the <code>solar</code> user's password).</p>"},{"location":"users/sysadmin/solarnode-service/#solarnode-service-environment","title":"SolarNode service environment","text":"<p>You can modify the environment variables passed to the SolarNode service, as well as modify the Java runtime options used. You may want to do this, for example, to turn on Java remote debugging support or to give the SolarNode process more memory.</p> <p>The systemd <code>solarnode.service</code> unit will load the <code>/etc/solarnode/env.conf</code> environment configuration file if it is present. You can define arbitrary environment variables using a simple <code>key=value</code> syntax.</p> <p>SolarNodeOS ships with a <code>/etc/solarnode/env.conf.example</code> file you can use for reference.</p>"},{"location":"users/sysadmin/solarssh/","title":"SolarSSH","text":"<p>The <code>sn-solarssh</code> package in SolarNodeOS provides a <code>solarssh</code> command-line tool for managing SolarSSH connections.</p>"},{"location":"users/sysadmin/solarssh/#show-ssh-public-key","title":"Show SSH public key","text":"<p>To view the node's public SSH key, you can execute <code>solarssh showkey</code>.</p> <pre><code>$ solarssh showkey\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIG7DWIuC2MVHy/gfD32sCayoVFpGVbZ8VXuQubmKjwyx SolarNode\n</code></pre>"},{"location":"users/sysadmin/solarssh/#list-solarssh-sessions","title":"List SolarSSH sessions","text":"<p>Run <code>solarssh list</code> to view all available SolarSSH sessions.</p> <pre><code>$ solarssh list\nb0ae36e0-06ae-4d3d-b34e-9bf2ca8049f1,ssh.solarnetwork.net,8022,43340\n</code></pre>"},{"location":"users/sysadmin/solarssh/#view-solarssh-session-status","title":"View SolarSSH session status","text":"<p>Using the output of <code>solarssh list</code> you can view the SSH connection status of a specific SSH session with <code>solarssh status</code>, like this:</p> <pre><code>$ solarssh -c b0ae36e0-06ae-4d3d-b34e-9bf2ca8049f1,ssh.solarnetwork.net,8022,43340 status\nactive\n</code></pre>"},{"location":"users/sysadmin/solarssh/#stop-solarssh-session","title":"Stop SolarSSH session","text":"<p>You can force a SolarSSH session to end using <code>solarssh stop</code>, like this:</p> <pre><code>$ solarssh -c b0ae36e0-06ae-4d3d-b34e-9bf2ca8049f1,ssh.solarnetwork.net,8022,43340 stop\n</code></pre>"}]}